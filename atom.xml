<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Diego Blog]]></title>
  <link href="http://testDiego.github.io/atom.xml" rel="self"/>
  <link href="http://testDiego.github.io/"/>
  <updated>2014-08-20T00:26:51-07:00</updated>
  <id>http://testDiego.github.io/</id>
  <author>
    <name><![CDATA[Diego]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Semihosting Con OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/17/semihosting-con-openocd/"/>
    <updated>2014-08-17T22:43:53-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/17/semihosting-con-openocd</id>
    <content type="html"><![CDATA[<p>Si has tenido la oportunidad de programar en C para la computadora, entonces de seguro conocerás la función <code>printf</code>. Esta función no es ninguna instrucción de <strong>C</strong> pero si es parte de la <strong>libreria estandar de C</strong>.</p>

<p>Sin entrar en mucho detalles la función <code>printf</code> nos permite por lo general mandar información por pantalla. En la computadora típicamente es el monitor.</p>

<p>Cualquier compilador decente de <strong>C</strong> para cualquier plataforma, trae esta librería estándar incluida. El compilador <strong>GNU ARM</strong> no es la excepcion y podremos, en nuestro programa utilizar la función <code>printf</code>. ¿Pero como?, si nuestro micro no tiene una pantalla!!.</p>

<p>Bueno nuestro micro no, pero la computadora que usamos para programar y debuggear si. Podemos usar el <strong>debugger</strong> ( <em>en el caso de la tarjeta Nucleo-f072rb es el ST-Link</em> ) para mandar la informacion de la función <code>printf</code> de nuestro programa a la pantalla de <strong>OpenOCD</strong>.</p>

<p>Crearemos un nuevo proyecto con <strong>CMSIS</strong> incluido, como en el post <a href="http://testdiego.github.io/blog/2014/08/08/primer-programa-cmsis/"><strong>Primer Programa con CMSIS</strong></a>. Llamaremos a ese proyecto <code>test_semihosting</code>, y en el archivo <code>main.c</code> escribimos lo siguiente</p>

<!--more-->


<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f072xb.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">void</span> <span class="nf">initialise_monitor_handles</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">initialise_monitor_handles</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hola semihosting</span><span class="se">\n\r</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(;;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* bucle */</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;la variable i = %d</span><span class="se">\n\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fin del bucle</span><span class="se">\n\n\r</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Observa bien el codigo que acabas de escribir y nota que referenciamos la función <code>extern void initialise_monitor_handles(void)</code> esta funcion es la que habilitará al debugger para que despliegue la información por pantalla.</p>

<p>Es necesario mandar llamar esta función en tu programa antes de usar la función <code>printf</code>. tal como se aprecia en el codigo de ejemplo.</p>

<p>Aparte de lo anterior necesitaremos compilar el programa con un par de opciones extra. En las opciones del linker debemos colocar <code>--specs=rdimon.specs -lc -lrdimon</code>. En el archivo <strong>makefile</strong> escribe en <code>LCDFLAGS</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LDFLAGS = $(CPU) -Wl,--gc-sections --specs=rdimon.specs -lc -lrdimon</span></code></pre></td></tr></table></div></figure>


<p>Compila y conectate a la tarjeta con <strong>OpenOCD</strong>. Al momento de usar <strong>GDB</strong> debemos agregar <code>mon enable semihosting</code> a la lista de opciones que normalmente usamos cuando cargamos un programa. Aqui la lista de los comandos.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diego@diego-X55A:~/test_semihosting$ arm-none-eabi-gdb Output/test.elf
</span><span class='line'>GNU gdb (GNU Tools for ARM Embedded Processors) 7.6.0.20131129-cvs
</span><span class='line'>Copyright (C) 2013 Free Software Foundation, Inc.
</span><span class='line'>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span><span class='line'>This is free software: you are free to change and redistribute it.
</span><span class='line'>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
</span><span class='line'>and "show warranty" for details.
</span><span class='line'>This GDB was configured as "--host=i686-linux-gnu --target=arm-none-eabi".
</span><span class='line'>For bug reporting instructions, please see:
</span><span class='line'>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span><span class='line'>Reading symbols from /home/diego/test_semihosting/Output/test.elf...done.
</span><span class='line'>(gdb) target remote localhost:3333
</span><span class='line'>Remote debugging using localhost:3333
</span><span class='line'>0x00000000 in ?? ()
</span><span class='line'>(gdb) mon arm semihosting enable
</span><span class='line'>semihosting is enabled
</span><span class='line'>(gdb) load
</span><span class='line'>Loading section .isr_vector, size 0xc0 lma 0x8000000
</span><span class='line'>Loading section .text, size 0x759c lma 0x80000c0
</span><span class='line'>Loading section .rodata, size 0x3b0 lma 0x8007660
</span><span class='line'>Loading section .ARM, size 0x8 lma 0x8007a10
</span><span class='line'>Loading section .init_array, size 0x8 lma 0x8007a18
</span><span class='line'>Loading section .fini_array, size 0x4 lma 0x8007a20
</span><span class='line'>Loading section .data, size 0x8b4 lma 0x8007a24
</span><span class='line'>Start address 0x8002ebc, load size 33492
</span><span class='line'>Transfer rate: 22 KB/sec, 4186 bytes/write.
</span><span class='line'>(gdb) mon reset halt
</span><span class='line'>target state: halted
</span><span class='line'>target halted due to debug-request, current mode: Thread
</span><span class='line'>xPSR: 0xc1000000 pc: 0x08002ebc msp: 0x20003ffc, semihosting
</span><span class='line'>(gdb)</span></code></pre></td></tr></table></div></figure>


<p>Coloca un breakpoint en la linea <code>printf("fin del bucle\n\n\r");</code> y corre el programa. Podrás notar en la pantalla de <strong>GDB</strong> que nada aparece, pero si revisas la terminal en la que tienes corriendo <strong>OpenOCD</strong> podras ver la informacion enviada por <code>printf</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hola semihosting
</span><span class='line'>la variable i = 0
</span><span class='line'>la variable i = 1
</span><span class='line'>la variable i = 2
</span><span class='line'>la variable i = 3
</span><span class='line'>la variable i = 4
</span><span class='line'>la variable i = 5
</span><span class='line'>la variable i = 6
</span><span class='line'>la variable i = 7
</span><span class='line'>la variable i = 8
</span><span class='line'>la variable i = 9</span></code></pre></td></tr></table></div></figure>


<p>Mola bastante verdad!!!, Pero antes de que te alegres deberías observar el tamaño de tu programa. Cuando usaste <code>load</code> GDB te dio esta información.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Start address 0x8002ebc, load size 33492</span></code></pre></td></tr></table></div></figure>


<p><strong>33K de codigo!!!!</strong>. Oh si!.  Usar la librería estándar agrega bastante código extra a tu programa y siendo honestos la libreria estandar de <strong>C</strong> que viene con <strong>GNU ARM</strong> no es la version completa. Se usa una version reducida, especial para embedded llamada <strong>newlib</strong>. Que, ¿creias que era gratis?.</p>

<h2>Usando newlib-nano</h2>

<p>Se puede usar una versión reducida de la aún reducida libreria estándar que acompaña a <strong>GNU ARM</strong> la version <strong>newlib-nano</strong>, solo necesitaras pasar al compilador las siguientes opciones <code>-Os -flto -ffunction-sections -fdata-sections -fno-builtin</code> y en el linker las opciones <code>--specs=nano.specs -lc -lnosys</code>.</p>

<p>Asi que  en tu makefile en GCFLAGS quedaria asi</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CCFLAGS = $(CPU) $(INCLUDES) -Wall -fno-common -O0 -fomit-frame-pointer -Wstrict-prototypes -fverbose-asm -Os -flto -ffunction-sections -fdata-sections -fno-builtin</span></code></pre></td></tr></table></div></figure>


<p>Y en LDFLAGS quedaría de este modo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LDFLAGS = $(CPU) -Wl,--gc-sections --specs=rdimon.specs -lc -lrdimon --specs=nano.specs -lc -lnosys</span></code></pre></td></tr></table></div></figure>


<p>Vuelve a repetir el proceso anterior de compilar, conectar OpenOCD y cargar con GDB tu programa. Fijate cuando usas <code>load</code> la cantidad de codigo que en esta ocasion se carga a tu micro.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Start address 0x8000b44, load size 5520</span></code></pre></td></tr></table></div></figure>


<p>Wow!. Se redujo a tan solo 5K, una cantidad mas considerable. Pero existe un precio como la imposibilidad de manejar numeros flotantes en la funcion <code>printf</code></p>

<h2>Uso de Stack y Heap</h2>

<p>Bueno no solo memoria de programa se consume por la funcion printf. Tambien se consume memoria RAM, <strong>stack</strong> y <strong>heap</strong> para ser mas especificos. Abre el archivo <strong>STM32F072RB_FLASH.ld</strong> con tu editor de texto y fijate en las líneas 37 y 38</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_Min_Heap_Size = 0x200;      /* required amount of heap  */
</span><span class='line'>_Min_Stack_Size = 0x400;     /* required amount of stack */</span></code></pre></td></tr></table></div></figure>


<p>En este archivo se le da al stack 2k de memoria y al heap 1k. El uso de stack es muy común pues aquí es donde se almacenan las variables locales, pero a menos que se maneje memoria dinámica el valor de heap sera 0.</p>

<p>En este caso el archivo linker de ejemplo que usamos por default ya trae estos valores pero cuando no los tenga y uses la librería estándar ya sabes que deberás darle un valor adecuado ( <em>como entre 1k y 2k esta bien</em> )</p>

<h2>Conclusion</h2>

<p>El uso de la función <code>printf</code> es muy interesante, en especial en la etapa de desarrollo de tu proyectos, se vuelve tentadora la idea de usarla para depurar tu programa y poblar el software con cientos de <code>printf</code>. Pero como ves su uso no es gratuito y solo será útil mientras tengas un debugger conectado a tu micro, una vez que lo retires no servira de nada.</p>

<p>Por cierto la librería estándar no solo es la función printf, hay mucho más. Por que no vas y se lo preguntas a tu buscador favorito.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Con OpenOCD Y GDB (Pt II)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/17/debugging-con-openocd-y-gdb-pt-ii/"/>
    <updated>2014-08-17T13:37:42-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/17/debugging-con-openocd-y-gdb-pt-ii</id>
    <content type="html"><![CDATA[<p>Continuamos con <strong>GDB</strong> y en esta ocasion veremos como observar el contenido de las variables y de los registros. Seguiremos retomando el programa que usamos en la <a href="http://localhost:4000/blog/2014/08/17/debugging-con-openocd-y-gdb/"><strong>primera parte</strong></a>.</p>

<p>Lo primero que haremos sera modificar un poco nuestro prgrama, agregaremos unas variables que seran las que observemos. Abre el archivo <code>main.c</code> con tu editor favorito y modificalo de la siguiete manera</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f072xb.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define LED_PIN 5</span>
</span><span class='line'>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/*variable iniciada a cero*/</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/*variable iniciada a dos*/</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tres</span><span class="p">;</span>  <span class="cm">/*variable con valor incial indeterminado*/</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Enable GPIOA clock */</span>
</span><span class='line'>    <span class="n">RCC</span><span class="o">-&gt;</span><span class="n">AHBENR</span> <span class="o">|=</span> <span class="n">RCC_AHBENR_GPIOAEN</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 as output */</span>
</span><span class='line'>    <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">MODER</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 in max speed */</span>
</span><span class='line'>    <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span><span class="p">(;;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Toggle pin 5 from port A */</span>
</span><span class='line'>        <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">ODR</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LED_PIN</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/*incrementamos variables de prueba*/</span>
</span><span class='line'>        <span class="n">uno</span><span class="o">++</span><span class="p">;</span>     <span class="cm">/*incremento en uno*/</span>
</span><span class='line'>        <span class="n">dos</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/*incremento en dos*/</span>
</span><span class='line'>        <span class="n">tres</span><span class="o">++</span><span class="p">;</span>    <span class="cm">/*incremnteo en uno*/</span>
</span><span class='line'>        <span class="cm">/* simple and practical delay */</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">300000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>
Compila el programa y conecta <strong>OpenOCD</strong>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ make
</span><span class='line'>$ sudo openocd</span></code></pre></td></tr></table></div></figure>


<p>Carga el programa con <strong>GDB</strong>, recuerda que todo en esto es en otra terminal</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ arm-none-eabi-gdb Output/test.elf
</span><span class='line'>GNU gdb (GNU Tools for ARM Embedded Processors) 7.6.0.20131129-cvs
</span><span class='line'>Copyright (C) 2013 Free Software Foundation, Inc.
</span><span class='line'>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span><span class='line'>This is free software: you are free to change and redistribute it.
</span><span class='line'>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
</span><span class='line'>and "show warranty" for details.
</span><span class='line'>This GDB was configured as "--host=i686-linux-gnu --target=arm-none-eabi".
</span><span class='line'>For bug reporting instructions, please see:
</span><span class='line'>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span><span class='line'>Reading symbols from /home/diego/test_f072_CMSIS/Output/test.elf...done.
</span><span class='line'>(gdb) target remote localhost:3333
</span><span class='line'>Remote debugging using localhost:3333
</span><span class='line'>0x00000000 in ?? ()
</span><span class='line'>(gdb) load
</span><span class='line'>Loading section .isr_vector, size 0xc0 lma 0x8000000
</span><span class='line'>Loading section .text, size 0x484 lma 0x80000c0
</span><span class='line'>Loading section .rodata, size 0x8 lma 0x8000544
</span><span class='line'>Loading section .init_array, size 0x8 lma 0x800054c
</span><span class='line'>Loading section .fini_array, size 0x4 lma 0x8000554
</span><span class='line'>Loading section .data, size 0x440 lma 0x8000558
</span><span class='line'>Start address 0x8000378, load size 2456
</span><span class='line'>Transfer rate: 12 KB/sec, 409 bytes/write.
</span><span class='line'>(gdb) mon reset halt
</span><span class='line'>target state: halted
</span><span class='line'>target halted due to debug-request, current mode: Thread
</span><span class='line'>xPSR: 0xc1000000 pc: 0x08000378 msp: 0x20003ffc</span></code></pre></td></tr></table></div></figure>


<p>Vamos a colocar un <strong>breakpoint</strong> justo en  el mismo lugar que el anterior <code>GPIOA-&gt;ODR ^= (1 &lt;&lt; LED_PIN);</code>. Pero como modifcamos el programa, ahora se encuntra en un numero de linea diferente.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) b main.c:25
</span><span class='line'>Breakpoint 1 at 0x8000154: file main.c, line 25.</span></code></pre></td></tr></table></div></figure>


<p>Corre el programa con <code>c</code> para que se dentenga justo en el breakpoint.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) c
</span><span class='line'>Continuing.
</span><span class='line'>Breakpoint 1, main () at main.c:25
</span><span class='line'>25          GPIOA-&gt;ODR ^= (1 &lt;&lt; LED_PIN);</span></code></pre></td></tr></table></div></figure>


<h2>Mostrando valores de variables</h2>

<p>Bien ahora que el programa esta detenido podemos preguntar que valor poseen las variables justo en este punto del programa, y para ello usamos el comando <code>print</code> mejor abreviado como <code>p</code>. Preguntaremos por la varibale <code>uno</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p uno
</span><span class='line'>$1 = 0</span></code></pre></td></tr></table></div></figure>


<p>Como puedes ver nos arroja el valor en decimal que posee la variable en ese momento. Ahora te toca a ti. Pregunta por el valor de las otras dos variables, <code>dos</code> y <code>tres</code>.</p>

<p>Corre de nueva cuenta el programa con <code>c</code>. Segun nuestro codigo las variables se incrementaran en uno y dos valores. Asi que de nueva cuenta interroga por el valor de las variables y observa como su valor efectivamente se incrementa. Yo observare cuanto vale <code>dos</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p dos
</span><span class='line'>$2 = 4</span></code></pre></td></tr></table></div></figure>


<p>El comando <code>print</code> o <code>p</code> pude imprimir el valor de una variable en mas tipos de formatos a parte del decimal (default) solo deberemos agregar <code>\x</code> donde x es la letra correspodiente al formato. Ejemplo</p>

<p><strong>hexadecimal</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/x dos
</span><span class='line'>$3 = 0x4</span></code></pre></td></tr></table></div></figure>


<p><strong>binario</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/t dos
</span><span class='line'>$3 = 100</span></code></pre></td></tr></table></div></figure>


<p>Existen mas formatos como octal, sin signo o caracter. Puedes revisar <a href="http://davis.lbl.gov/Manuals/GDB/gdb_9.html#SEC58"><strong>Aqui</strong></a></p>

<h2>Mostrando valores de registros</h2>

<p>No solo de las variables podemos observar sus valores actuales, que tal si queremos saber el contenido actual del registro <code>ODR</code>. Y saber si efectivamente el <strong>bit 5</strong> vale uno o dos.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/x GPIOA-&gt;ODR
</span><span class='line'>No symbol "GPIOA" in current context.</span></code></pre></td></tr></table></div></figure>


<p>Oh sorpresa!. No se puede, asi es no se puede porque <code>GPIOA</code> no es ninguna variable es una definicion, de un puntero a una estructura para ser mas exactos. Pero lo que si se puede es indicar que nos muestre la informacion de una direccion de memoria y resulta que el registro <code>GPIOA-&gt;ODR</code> se encuntra en la direccion <code>0x48000014</code>.
Lo expresamos en hexadecimal y realizamos un pequeño cast a la direccion</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/x *(int*)0x48000014
</span><span class='line'>$6 = 0x20</span></code></pre></td></tr></table></div></figure>


<p>Otra manera alterna es usar <code>x</code>. El cual es el comando para indicar contenidos de direcciones de memoria.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) x 0x48000014
</span><span class='line'>0x48000014: 0x00000020</span></code></pre></td></tr></table></div></figure>


<p>Dale continue con <code>c</code> y vuelve a imprimir el valor de la direccion para que observes como el bit 5 cambia de valor ( <em>y ve como concuerda con el led</em> ).</p>

<p>Tengo que admitirlo, tener que saber la direccion de cada registro de cada periferico del micro, es algo engorroso y te obliga a tener siempre a la mano la hoja de datos del micro ( <em>o el archivo stm32f072xb.h</em> ). Que se le va haser.</p>

<h2>La opcion -g3 de GCC</h2>

<p>No todo esta perdido, memorizar las direcciones de los registros no es la unica opcion. Simplemente debemos compilar nuestro prgrama con la opcion -g3 ( <em>actualmente lo hacemos solo con al opcion -g</em> ).</p>

<p>Hasique abre el archivo makefile de tu proyecto con tu editor de texto favorito y realiza el siguiente cambio
modifica la linea siguiente. De esto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$(CC) $(CCFLAGS) -c -g -o $@ $^</span></code></pre></td></tr></table></div></figure>


<p>a esto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$(CC) $(CCFLAGS) -c -g3 -o $@ $^</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Compila de nuevo y carga de nuevo el programa a tu tarjeta usando OpenOCD y GDB, coloca el breakpoint corre el program y cuando se detenga pregunta por el valor de <code>GPIOA-&gt;ODR</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/x GPIOA-&gt;ODR
</span><span class='line'>$7 = 0x20</span></code></pre></td></tr></table></div></figure>


<p>Tu programa se puede compilar para generar informacion que ayudara al debugger a rastrear tu programa, tal como lo estamos haciendo. Existen tres niveles de informacion con la que podemos compilar. <code>-g0, -g1, -g2</code> y <code>-g3</code>. siendo <code>-g0</code> ninguna infromacion para debuggear y <code>-g3</code> el maximo nivel de informacion que podemos tener. El nivel por default es <code>-g2</code> o <code>-g</code>.</p>

<p>Para informacion mas a detalle de GCC y GDB revisa</p>

<ul>
<li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Debugging-Options.html#Debugging-Options"><strong>GCC Debugging options</strong></a></p></li>
<li><p><a href="http://davis.lbl.gov/Manuals/GDB/gdb_9.html#SEC58"><strong>GDB print option</strong></a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Con OpenOCD Y GDB (Pt I)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/14/debugging-con-openocd-y-gdb/"/>
    <updated>2014-08-14T23:12:51-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/14/debugging-con-openocd-y-gdb</id>
    <content type="html"><![CDATA[<p>Llegó el momento de sacar mayor provecho al programador de nuestra tarjeta y es que nos solo sirve para programar. <strong>ST-Link</strong> nos sirve para depurar nuestro programa, realizar cosas como ejecuciones paso a paso, colocar breakpoints, revisar el contenido de una variable o registro, etc.</p>

<p>Antes de empezar deberemos tener un proyecto con el cual trabajar, así que tomaremos el proyecto del post <a href="http://testdiego.github.io/blog/2014/08/08/primer-programa-cmsis/"><strong>Primer Programa con CMSIS</strong></a>. Asegúrate de que compile sin errores ( <em>puedes probarlo antes en la tarjeta</em> ).</p>

<p>Bien, hora de conectarse a nuestra <strong>Nucleo-f072</strong> usando <strong>OpenOCD</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Wow!! Espera un segundo, mejor en vez de hacerlo de la manera tradicional, escribamos un archivo <strong>.cfg</strong> con las instrucciones para que <strong>OpenOCD</strong> se conecte. Si ya te conectaste solo presiona <code>Ctrl+C</code> para desconectarte.</p>

<p>En la misma carpeta de tu proyecto crea el archivo <strong>openocd.cfg</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072_CMSIS/openocd.cfg</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo recién creado con tu editor de texto favorito y escribe lo siguiente</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Indicamos que usaremos stlink como programador
</span><span class='line'>source [find interface/stlink-v2-1.cfg]
</span><span class='line'>
</span><span class='line'># Indicamos que es micro Cortex-M0 de la marca ST
</span><span class='line'>source [find target/stm32f0x_stlink.cfg]
</span><span class='line'>
</span><span class='line'># usamos hardware reset, para conectarnos solo bajo reset
</span><span class='line'>reset_config srst_only srst_nogate</span></code></pre></td></tr></table></div></figure>


<p>Ahora si, nos conectamos usando <strong>OpenOCD</strong> y el archivo que acabamos de crear.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ sudo openocd</span></code></pre></td></tr></table></div></figure>


<p>Si tienes dudas de lo anterior, solo recuerda que lo explicamos en el anterior post <a href="http://testdiego.github.io/blog/2014/08/13/programando-con-openocd/"><strong>Programando con OpenOCD</strong></a>.</p>

<h2>Usando GDB</h2>

<p>GDB es uno de los programas que vienen con tu compilador <strong>GNU ARM</strong> el cual instalaste en el <a href="http://testdiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm/"><strong>primer post</strong></a> y basicamente nos servira para ejecutar nuestro programa de manera guiada por asi decirlo. Solo continua con las instrucciones y te daras cuenta a que me refiero.</p>

<p>Abrimos otra terminal y en ella ejecutaremos <strong>gdb</strong> invocando el archivo <strong>.elf</strong> que nos arrojó la compilación de nuestro proyecto ( <em>Revisa la carpeta Output de tu proyecto</em> )</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ arm-none-eabi-gdb Output/test.elf</span></code></pre></td></tr></table></div></figure>


<p><strong>gdb</strong> nos arrojará la siguiente información por pantalla.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GNU gdb (GNU Tools for ARM Embedded Processors) 7.6.0.20131129-cvs
</span><span class='line'>Copyright (C) 2013 Free Software Foundation, Inc.
</span><span class='line'>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span><span class='line'>This is free software: you are free to change and redistribute it.
</span><span class='line'>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
</span><span class='line'>and "show warranty" for details.
</span><span class='line'>This GDB was configured as "--host=i686-linux-gnu --target=arm-none-eabi".
</span><span class='line'>For bug reporting instructions, please see:
</span><span class='line'>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span><span class='line'>Reading symbols from /home/diego/test_f072_CMSIS/Output/test.elf...done.
</span><span class='line'>(gdb)</span></code></pre></td></tr></table></div></figure>


<p>En la terminal tendremos el prompt correspondiente a <strong>gdb</strong> el cual nos indica que se esta ejecutando y que podremos escribir un comando para poner en funcionamiento nuestro programa.</p>

<p>Lo primero que debemos hacer es conectarnos al puerto <strong>3333</strong> que tiene disponible <strong>OpenOCD</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) target remote localhost:3333
</span><span class='line'>Remote debugging using localhost:3333
</span><span class='line'>0x00000000 in ?? ()</span></code></pre></td></tr></table></div></figure>


<p>Ya conectado <strong>OpenOCD</strong> con <strong>GDB</strong> lo siguiente es cargar a la memoria del micro nuestro programa. Lo hacemos con el comando <code>load</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) load
</span><span class='line'>Loading section .isr_vector, size 0xc0 lma 0x8000000
</span><span class='line'>Loading section .text, size 0x484 lma 0x80000c0
</span><span class='line'>Loading section .rodata, size 0x8 lma 0x8000544
</span><span class='line'>Loading section .init_array, size 0x8 lma 0x800054c
</span><span class='line'>Loading section .fini_array, size 0x4 lma 0x8000554
</span><span class='line'>Loading section .data, size 0x440 lma 0x8000558
</span><span class='line'>Start address 0x8000378, load size 2456
</span><span class='line'>Transfer rate: 12 KB/sec, 409 bytes/write.</span></code></pre></td></tr></table></div></figure>


<p>Aplicamos un reset para iniciar desde la primera dirección de nuestro programa</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) mon reset halt
</span><span class='line'>target state: halted
</span><span class='line'>target halted due to debug-request, current mode: Thread
</span><span class='line'>xPSR: 0xc1000000 pc: 0x08000378 msp: 0x20003ffc</span></code></pre></td></tr></table></div></figure>


<p>A partir de este punto podemos empezar la ejecución del programa que tiene en memoria el micro. Podemos simplemente poner a correr el programa, pero mejor le diremos que solo lo corra hasta cierto punto.</p>

<p>Insertaremos un <strong>breakpoint</strong> justo en la línea del programa que invierte el estado del led. Revisa tu archivo <code>main.c</code> y fijate bien que numero de linea es donde se encuentra la instrucción <code>GPIOA-&gt;ODR ^= (1 &lt;&lt; LED_PIN);</code> . En <strong>gdb</strong> escribe. ( <em>en nuestro caso es la línea 19</em> )</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) b main.c:19
</span><span class='line'>Breakpoint 1 at 0x8000154: file main.c, line 19.</span></code></pre></td></tr></table></div></figure>


<p>Ponemos a correr al micro con el comando <code>c</code> de <em>continue</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) c
</span><span class='line'>Continuing.
</span><span class='line'>Note: automatically using hardware breakpoints for read-only addresses.
</span><span class='line'>
</span><span class='line'>Breakpoint 1, main () at main.c:19
</span><span class='line'>19          GPIOA-&gt;ODR ^= (1 &lt;&lt; LED_PIN);</span></code></pre></td></tr></table></div></figure>


<p>Puedes observar en la terminal como <strong>gdb</strong> te indica que el programa se detuvo justo en la línea donde colocaste el breakpoint.</p>

<p>Vuelve a correr el programa con el comando <code>c</code> y observaras de nueva cuenta que se detiene en el <strong>breakpoint</strong>, observa tu tarjeta y ve como cada que presionas el comando <code>c</code> el led se invierte.</p>

<p>Puedes colocar mas <strong>breakpoints</strong> en diferentes lugares de tu código, solo no te olvides donde los pusiste, y si se te olvide solo escribe <code>info break</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) info break
</span><span class='line'>Num     Type           Disp Enb Address    What
</span><span class='line'>1       breakpoint     keep y   0x08000154 in main at main.c:19
</span><span class='line'>    breakpoint already hit 2 times</span></code></pre></td></tr></table></div></figure>


<p>Si quieres que el program no se detenga y se ejecute de manera continua tendrás que borrar el <strong>breakpoint</strong>. Lo puedes hacer con <code>clear</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) clear main.c:19
</span><span class='line'>Deleted breakpoints 1</span></code></pre></td></tr></table></div></figure>


<p>En este caso el breakpoint estaba en el archivo <code>main.c</code>, linea <strong>19</strong></p>

<p>Escribe <code>c</code> para que tu program empiece a correr, ya sin ningun breakpoint que lo detenga. Mira como parpadea el led!!.</p>

<p>Para detener la ejecución de tu programa tendrás que ejecutar un <code>Ctrl+C</code>. El programa se detendrá justo en la instrucción que estaba ejecutando. En nuestro caso fue el ciclo for</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^C
</span><span class='line'>Program received signal SIGINT, Interrupt.
</span><span class='line'>0x0800016e in main () at main.c:21
</span><span class='line'>21          for(i=0;i&lt;300000;i++);</span></code></pre></td></tr></table></div></figure>


<p>Para salir de <strong>gdb</strong> solo escribe <code>q</code>, nos pedira confirmacion asi que tecleamos <code>y</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) q
</span><span class='line'>A debugging session is active.
</span><span class='line'>
</span><span class='line'>    Inferior 1 [Remote target] will be detached.
</span><span class='line'>
</span><span class='line'>Quit anyway? (y or n) y
</span><span class='line'>Detaching from program: /home/diego/test_f072_CMSIS/Output/test.elf, Remote target
</span><span class='line'>Ending remote debugging.</span></code></pre></td></tr></table></div></figure>


<p>Que tal, a que no sabias que se podía hacer. Nah, probablemente si. Para terminar <strong>GDB</strong> es una herramienta muy buena para depurar y encontrar errores en tu programa cuando estas en la fase de desarrollo. Hay muchas cosas mas interesantes que se pueden hacer con gdb, pero eso lo veremos mas adelante.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programando Con OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/13/programando-con-openocd/"/>
    <updated>2014-08-13T20:39:06-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/13/programando-con-openocd</id>
    <content type="html"><![CDATA[<p>Existen diferentes maneras en que podemos programar nuestro microcontrolador usando <strong>OpenOCD</strong>, ( <em>una muestra de su versatilidad</em> ), y en este nuevo post examinaremos algunas de ellas, quedara en ti escoger la más adecuada para tu sistema de trabajo.</p>

<p>Antes que nada y para simplificar un poco utilizaremos el programa que creamos en el post <a href="http://testdiego.github.io/blog/2014/08/06/primer-programa-bare-board"><strong>Primer Programa Bare Board</strong></a> y daremos por echo que ya esta correctamente compilado y tenemos los archivos tets.elf y test.hex generados en el subfolder Output.</p>

<h2>Usando Telnet</h2>

<p>Esta opción ya la hemos manejado en los anteriores post, pero no está de más incluirla aquí. Primero que nada tendrás que conectarte a tu tarjeta con <strong>OpenOCD</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en alcarpeta del proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Recuerda que debes indicar la interfaz que manejas ( <em>en este caso stlink</em> ) y el micro a programar ( <em>en este caso stm32f0</em> ). Y eso es lo que se hace en el código de arriba.</p>

<p>Por default <strong>OpenOCD</strong> estará escuchando en el <strong>puerto 4444</strong> para aceptar conexiones por <strong>telnet</strong>, así que lo siguiente es usar el programa <strong>telnet</strong> para conectarnos a ese mismo puerto. En otra terminal escribimos</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ telnet localhost 4444</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Notamos como <strong>OpenOCD</strong> nos acepta la conexión, con lo cual estamos listos para mandarle comandos y que este los ejecute. Puedes investigar cuales son los comandos que acepta <strong>OpenOCD</strong> leyendo su manual de usuario.</p>

<p>Para programar la memoria del micro se usarán los siguientes</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset halt
</span><span class='line'>flash write_image erase Output/test.hex
</span><span class='line'>reset run
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Usando solo OpenOCD</h2>

<p>Se puede usar únicamente <strong>OpenOCD</strong> sin necesitar de un programa externo como <strong>telnet</strong> para programar el micro. Simplemente le debes pasar algunos comandos a <strong>OpenOCD</strong> al momento de invocarlo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg -c "program Output/test.hex verify reset"</span></code></pre></td></tr></table></div></figure>


<p>Si observas bien puedes darte cuenta que con la bandera <code>-c</code> puedes pasar comandos a <strong>OpenOCD</strong>. En este caso le estamos indicando que programe el micro con el archivo <strong>.hex</strong> <code>Output/test.hex</code> y que después de hacer la programación realice una verificación y un reset.</p>

<p>Esta nueva forma hace que <strong>OpenOCD</strong> se conecte a nuestro micro, cargue el programa, lo verifique y ponga correr el programa para después desconectarse de la tarjeta.</p>

<h2>Usando Archivos .cfg con OpenOCD</h2>

<p>El anterior método resultó ser mucho más corto y sencillo que el anterior con <strong>telnet</strong>, pero en contra está la kilométrica línea con la que debemos invocar <strong>OpenOCD</strong> desde la terminal. Lo cual lo hace bastante engorroso y fácil de cometer equivocaciones.</p>

<p>Para evitar lo anterior escribiremos los argumentos con los que invocamos <strong>OpenOCD</strong> en un archivo <code>.cfg</code> ( <em>que son los que entiende OpenOCD</em> ) así que en la misma carpeta de tu proyecto crea el archivo <strong>openocd.cfg</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072/openocd.cfg</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo recién creado con tu editor de texto favorito y escribe lo siguiente</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Indicamos que usaremos stlink como programador
</span><span class='line'>source [find interface/stlink-v2-1.cfg]
</span><span class='line'>
</span><span class='line'># Indicamos que es micro Cortex-M0 de la marca ST
</span><span class='line'>source [find target/stm32f0x_stlink.cfg]
</span><span class='line'>
</span><span class='line'># Programamos el archivo "test.hex" que se encuentra en la carpeta
</span><span class='line'># Output de nuestro proyecto y despues verificamos y damos un reset
</span><span class='line'>program Output/test.hex verify reset
</span></code></pre></td></tr></table></div></figure>


<p>Ahora tenemos los anteriores parámetros escritos en un archivo en la carpeta de nuestro proyecto, con lo cual invocar <strong>OpenOCD</strong> se vuelve mas sencillo. Solo escribimos</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ sudo openocd -f openocd.cfg</span></code></pre></td></tr></table></div></figure>


<p>Como puedes ver a <strong>OpenOCD</strong> lo invocamos pasando el nombre del archivo que contiene los comandos que se deben ejecutar al conectarse a nuestra tarjeta. Un metodo simple y rápido, que nos da pie a crear formas más flexibles de conectarnos y programar nuestros dispositivos.</p>

<p>Antes de terminar!!. ¿Porque nombramos a nuestro arcgivo <code>.cfg</code> con el nombre de <code>openocd</code>?, ¿por puro gusto?, ¿simple coincidencia?. No, fue intencional y es que resulta que <strong>OpenOCD</strong> por default se ejecutara con el archivo llamado <code>openocd.cfg</code> que se encuentre en el directorio en el que fue invocado.</p>

<p>Asi que podemos simplifar lo anterior aun mas</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
</span><span class='line'>$ sudo openocd</span></code></pre></td></tr></table></div></figure>


<h2>Conclusion</h2>

<p>Como puedes ver unas opciones parecen ser mejores que otras. Bueno eso dependerá de la forma que uses <strong>OpenOCD</strong>. Con telnet tienes una opción poderosa para realizar conexiones remotas, que tal si tu boards se encuentra conectado a una máquina diferente.</p>

<p>Y por otra parte los archivos <code>.cfg</code> son una herramienta poderosa al momento de crear diferentes configuraciones para acceder a tu tarjeta. Como sugrerencia crea el archivo <code>openocd.cfg</code> en la carpeta de cada proyecto en el que trabajes y veras como te ahorras tiempo al programar.</p>

<p>Si quieres mas información consulta el <strong>Manual de usuario de OpenOCD</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer Programa Con Stm32f0cube (Pt IV)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/11/primer-programa-con-stm32f0cube-ii/"/>
    <updated>2014-08-11T21:13:25-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/11/primer-programa-con-stm32f0cube-ii</id>
    <content type="html"><![CDATA[<p>La última parte de la serie <strong>Primer Programa</strong> en la cual abordaremos un poco más de la librería <strong>STM32F0Cube</strong>. Primero que nada una explicación de lo que contiene esta librería al descomprimir el archivo <strong>zip</strong> en el que viene, te encuentras con:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── Documentation
</span><span class='line'>├── Drivers
</span><span class='line'>├── _htmresc
</span><span class='line'>├── Middlewares
</span><span class='line'>├── package.xml
</span><span class='line'>├── Projects
</span><span class='line'>├── Release_Notes.html
</span><span class='line'>└── Utilities</span></code></pre></td></tr></table></div></figure>


<h4>Drivers</h4>

<p>Es uno de los directorios más importantes, en el encontramos el estándar <strong>CMSIS</strong> que contiene definidos los registros de los periféricos del micro así como los vectores de interrupción. Lo otro que encontramos de gran importancia es la librería de <strong>HAL drivers</strong> con las piezas de código que nos permitirán controlar los periféricos a través de funciones y macros ya bien definidos y probados.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── BSP
</span><span class='line'>├── CMSIS
</span><span class='line'>└── STM32F0xx_HAL_Driver</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h4>Middelwares</h4>

<p>Este es el segundo directorio de importancia el cual contiene librerias de codigo que nos permitiran realizar cosas mucho mas interesantes y que requieren un nivel mayor de expertis.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── ST
</span><span class='line'>│   ├── STM32_TouchSensing_Library
</span><span class='line'>│   └── STM32_USB_Device_Library
</span><span class='line'>└── Third_Party
</span><span class='line'>    ├── FatFs
</span><span class='line'>    └── FreeRTOS</span></code></pre></td></tr></table></div></figure>


<h4>Projects</h4>

<p>Aqui no encontrarás piezas de código reusables, solo unos cuantos ejemplos en los que se usa la librería para algunas tarjetas que están en el mercado entre las cuales encontramos la <strong>Nucleo-f072rb</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── STM32072B_EVAL
</span><span class='line'>├── STM32F0308-Discovery
</span><span class='line'>├── STM32F030R8-Nucleo
</span><span class='line'>├── STM32F072B-Discovery
</span><span class='line'>└── STM32F072RB-Nucleo</span></code></pre></td></tr></table></div></figure>


<p>El resto de los directorios son documentación y alguna utileria para actualizar la propia librería.</p>

<h2>Proyecto Recomendado por ST</h2>

<p>En la <a href="http://testdiego.github.io/blog/2014/08/10/primer-programa-con-stm32f0cube/"><strong>tercera parte</strong></a> de esta serie de post utilizamos las funciones que vienen con esta librería, si bien nuestro programa corrió exitosamente el codigo no esta ordenado de la forma que <strong>ST</strong> nos recomendaría si estamos usando <strong>STM32F0Cube</strong>. Así que lo correcto seria lo siguiente.</p>

<p>De nueva cuenta crea una nueva carpeta para nuestro proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072_cubeII</span></code></pre></td></tr></table></div></figure>


<p>Y al igual que en los anteriores deberás copiar a la carpeta de tu proyecto el archivo <strong>linker</strong>. Recuerda lo obtienes de la librería de <strong>ST</strong> en la siguiente ruta</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/TrueSTUDIO/STM32F072RB-Nucleo/STM32F072RB_FLASH.ld</span></code></pre></td></tr></table></div></figure>


<p>Bien, <strong>ST</strong> nos sugiere que ordenemos nuestro proyecto en dos directorios, uno donde iran los archivos headers ( <em>*.h</em> ) <strong>Inc</strong> y otro con los archivos fuente ( <em><em>.s y </em>.c</em> ) <strong>Src</strong>, asi que creamos estos directorios en nuestro proyecto.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072_cubeII/Inc
</span><span class='line'>$ mkdir ~/test_f072_cubeII/Src</span></code></pre></td></tr></table></div></figure>


<p>Los archivos que deberán ir en cada uno de los directorios los podremos crear desde cero o copiarlos de un lugar donde ya están escritos, como un template que viene en la librería.</p>

<p>Copia los siguientes archivos de la siguiente ruta en el directorio <strong>Inc</strong> de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Inc/main.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Inc/stm32f0xx_hal_conf.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Inc/stm32f0xx_it.h</span></code></pre></td></tr></table></div></figure>


<p>Y aqui la descripcion de cada uno de esos archivos</p>

<ul>
<li><strong>main.h.-</strong>Aquí colocaras las funciones, variables y/o macros que tengan carácter global y que deben referenciar otros archivos de tu programa</li>
<li><strong>stm32f0xx_hal_conf.h.-</strong> Viejo conocido en donde configuras lo que se use y lo que no se use de la librería STM32F0Cube</li>
<li><strong>stm32f0xx_it.h.-</strong> Aquí colocaras los prototipos de las funciones que actúan como vectores de interrupción</li>
</ul>


<p>Copia los siguientes archivos de la siguiente ruta en el directorio Src de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Src/main.c
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Inc/stm32f0xx_hal_msp.c
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/Inc/stm32f0xx_it.c</span></code></pre></td></tr></table></div></figure>


<p>Y aqui la descripcion de cada uno de los archivos</p>

<ul>
<li><strong>main.c.-</strong> Aqui va tu aplicación. Ya contiene algunas líneas de código que ST te sugiere que tenga por default</li>
<li><strong>stm32f0xx_hal_msp.c.-</strong> En este archivo colocaras las funciones callback que ocupes de la librería con código específico de tu aplicación</li>
<li><strong>stm32f0xx_it.c.-</strong> Aqui van los vectores de interrupción y donde típicamente mandas llamar las funciones que se necesiten ejecutar en una interrupción</li>
<li><strong>system_stm32f0xx.c.-</strong> Aqui se encuentra las configuraciones inciales de los reloj del sistema ( <em>ya no ocuparas hacerle cambios</em> )</li>
</ul>


<p>Tenemos que hacer una pequeña modificación en el archivo <strong>main.h</strong> para que nuestro proyecto no quede tan dependiente de la tarjeta <strong>Nucleo-f072rb</strong> y que quede más genérico. Abre el archivo con tu editor de texto favorito y sustituyes la <strong>línea 44</strong> por la siguiente</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>main.h</h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f0xx.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo <strong>main.c</strong> con tu editor de texto, podras observar bastante código ya escrito así como unos voluminosos comentarios escritos por los ingenieros de <strong>ST</strong>. No te asustes, si observamos la función main podras ver que se manda llamar la funcion ya conocida <code>HAL_Init()</code> y una nueva <code>SystemClock_Config()</code>, esta funcion cuyo cuerpo encuentras lineas mas abajo configura el reloj del sistema para uqe corra a 48MHz ( <em>velocidad maxima del micro</em> ) usando las funciones del periferico <strong>RCC</strong>.</p>

<p>Inserta la siguiente declaracion en la <strong>linea 53</strong></p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Private variables ---------------------------------------------------------*/</span>
</span><span class='line'><span class="k">static</span> <span class="n">GPIO_InitTypeDef</span>  <span class="n">GPIO_InitStruct</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* Private function prototypes -----------------------------------------------*/</span>
</span></code></pre></td></tr></table></div></figure>


<p>A partir de la línea  <strong>84</strong> colocaremos nuestro código y dentro del ciclo while infinito también</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="cm">/* -1- Enable each GPIO Clock (to be able to program the configuration registers) */</span>
</span><span class='line'>    <span class="n">__GPIOA_CLK_ENABLE</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* -2- Configure IOs in output push-pull mode to drive external LEDs */</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span>  <span class="o">=</span> <span class="n">GPIO_MODE_OUTPUT_PP</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pull</span>  <span class="o">=</span> <span class="n">GPIO_PULLUP</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Speed</span> <span class="o">=</span> <span class="n">GPIO_SPEED_HIGH</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span>   <span class="o">=</span> <span class="n">GPIO_PIN_5</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* -3- Toggle IOs in an infinite loop */</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">HAL_GPIO_TogglePin</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="n">GPIO_PIN_5</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* Insert delay 100 ms */</span>
</span><span class='line'>        <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Si eres observador notarás que la función <code>void SysTick_Handler(void)</code> ya no se encuentra en el archivo main.c. Como esta función es un vector de interrupción ahora se encuentra en el archivo <strong>stm32f0xx_it.c</strong> ( <em>linea 109</em> ).</p>

<p>Al directorio de tu proyecto le hace falta algo ( <em>no es el makefile</em> ) y es la libreria <strong>STM32F0Cube</strong> podemos copiarla al folder de tu proyecto como en el anterior post, nada mas te recuerdo que pesa <strong>82.3 MB</strong>.</p>

<p>La librería no está diseñada para la copies en cuanto proyecto trabajes, sino más bien la dejes en un lugar fijo y referencies sus directorios desde ese mismo lugar para todos tus proyectos.</p>

<p>Puedes dejarla en donde sea que la hayas descomprimido, pero que tal si las dejas en un lugar muy estándar de linux, tu home directory ( <strong>~ </strong> ), de tal manera que tu libreria tendría el siguiente destino. Esto ayudará mucho a la portabilidad de tus proyectos.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/STM32Cube_FW_F0_V1.0.0</span></code></pre></td></tr></table></div></figure>


<p>Por último, el archivo makefile para que make realice la compilación.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch test_f072_cubeII/makefile</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo en tu editor de texto y escribe el siguiente código. Recuerda usar TABs y no espacios para las indentación.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>makefile </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="nv">PROJECT</span> <span class="o">=</span> <span class="nb">test</span>
</span><span class='line'>
</span><span class='line'><span class="c"># archivos a compilar</span>
</span><span class='line'><span class="nv">FILES</span> <span class="o">=</span> main.o startup_stm32f072xb.o system_stm32f0xx.o stm32f0xx_it.o<span class="se">\</span>
</span><span class='line'>stm32f0xx_hal.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_rcc.o stm32f0xx_hal_rcc_ex.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_gpio.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_cortex.o <span class="se">\</span>
</span><span class='line'><span class="err">stm32f0xx_hal_flash.o</span>
</span><span class='line'>
</span><span class='line'><span class="c"># definiciones de control</span>
</span><span class='line'><span class="nv">DEFINES</span> <span class="o">=</span> -DSTM32F072xB -DUSE_HAL_DRIVER
</span><span class='line'>
</span><span class='line'><span class="c"># directorios con archivos fuente (*.c y *.s)</span>
</span><span class='line'><span class="nv">VPATH</span> <span class="o">=</span> Src <span class="se">\</span>
</span><span class='line'><span class="err">/home/diego/STM32Cube_FW_F0_V1.0.0/Drivers/STM32F0xx_HAL_Driver/Src</span>
</span><span class='line'>
</span><span class='line'><span class="c"># directorios con archivos headers (*.h)</span>
</span><span class='line'><span class="nv">INCLUDE</span> <span class="o">=</span> -I ./ <span class="se">\</span>
</span><span class='line'>-I ./Inc <span class="se">\</span>
</span><span class='line'>-I ~/STM32Cube_FW_F0_V1.0.0/Drivers/STM32F0xx_HAL_Driver/Inc <span class="se">\</span>
</span><span class='line'>-I ~/STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Include <span class="se">\</span>
</span><span class='line'><span class="err">-I</span> <span class="err">~/STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include</span>
</span><span class='line'>
</span><span class='line'><span class="c"># a partir de aquí no modifiques nada a menos que sepas lo que haces</span>
</span><span class='line'><span class="c"># linker script to be use</span>
</span><span class='line'><span class="nv">LINKERFILE</span> <span class="o">=</span> STM32F072RB_FLASH.ld
</span><span class='line'><span class="nv">CPU</span> <span class="o">=</span> -mcpu<span class="o">=</span>cortex-m0 -mthumb -mlittle-endian
</span><span class='line'>
</span><span class='line'><span class="nv">AS</span> <span class="o">=</span> arm-none-eabi-as
</span><span class='line'><span class="nv">CC</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">LD</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">OD</span> <span class="o">=</span> arm-none-eabi-objdump
</span><span class='line'><span class="nv">OC</span> <span class="o">=</span> arm-none-eabi-objcopy
</span><span class='line'>
</span><span class='line'><span class="nv">CCFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> <span class="k">$(</span>DEFINES<span class="k">)</span> <span class="k">$(</span>INCLUDE<span class="k">)</span> -Wall -fno-common -O0 -fomit-frame-pointer -Wstrict-prototypes -fverbose-asm
</span><span class='line'><span class="nv">ASFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span>
</span><span class='line'><span class="nv">LDFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> -Wl,--gc-sections
</span><span class='line'><span class="nv">OCFLAGS</span> <span class="o">=</span> -Oihex
</span><span class='line'><span class="nv">ODFLAGS</span> <span class="o">=</span> -S
</span><span class='line'>
</span><span class='line'><span class="nf">all </span><span class="o">:</span> <span class="n">test</span>
</span><span class='line'>
</span><span class='line'><span class="nf">test </span><span class="o">:</span> <span class="k">$(</span><span class="nv">PROJECT</span><span class="k">)</span>.<span class="n">elf</span>
</span><span class='line'>    <span class="k">$(</span>OC<span class="k">)</span> <span class="k">$(</span>OCFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf <span class="k">$(</span>PROJECT<span class="k">)</span>.hex
</span><span class='line'>    <span class="k">$(</span>OD<span class="k">)</span> <span class="k">$(</span>ODFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf &gt; <span class="k">$(</span>PROJECT<span class="k">)</span>.lst
</span><span class='line'>    mv *.o *.elf *.hex *.lst Output
</span><span class='line'>
</span><span class='line'><span class="nf">$(PROJECT).elf </span><span class="o">:</span> <span class="k">$(</span><span class="nv">FILES</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -T<span class="k">$(</span>LINKERFILE<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile C source files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CCFLAGS<span class="k">)</span> -c -g -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile ASM files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>    <span class="k">$(</span>AS<span class="k">)</span> <span class="k">$(</span>ASFLAGS<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean </span><span class="o">:</span>
</span><span class='line'>    rm Output/*.*
</span></code></pre></td></tr></table></div></figure>


<p>Fijate que ahora direccionamos los directorios de la librería desde su nuevo destino que seria tu directorio de usuario <strong>ST</strong>.</p>

<p>A compilar se ha dicho</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cubeII
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>Si la terminal no arrojo ningun error deberemos tener nuestro archivo <strong>test.hex</strong> en la carpeta Output</p>

<h2>A Programar se ha dicho</h2>

<p>Abre una nueva terminal y conectate con tu tarjeta usando OpenOCD</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cubeII  #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<p>En la terminal anterior madaremos nuestro programa compilado a nuestra tarjeta usando <strong>telnet</strong>, conectate al puerto <strong>4444</strong> de la siguiente manera</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cubeII #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ telnet localhost 4444</span></code></pre></td></tr></table></div></figure>


<p>Si te acepta la conexion, solo restara mandar el archivo <strong>.hex</strong>. Escribe los siguientes comandos en orden</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset halt
</span><span class='line'>flash write_image erase Output/test.hex
</span><span class='line'>reset run</span></code></pre></td></tr></table></div></figure>


<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Conclusion</h2>

<p>Bastantes archivos y codigo para un simple parpadeo de un led te estarás diciendo. Tienes razon pero piensa que la librería y sobre todos el ordenar tu proyecto de esta manera esta pensando para que realices desde pequeños hasta grandes proyectos con una gran cantidad de código y archivos fuente y es en estos último cuando adquiere gran importancia ordenar bien tu código.</p>

<p>Un punto muy importante que <strong>ST</strong> maneja una herramienta que permite configurar la librería <strong>STM32F0Cube</strong> y generar código a partir de una <a href="http://www.st.com/web/en/catalog/tools/PF259242"><strong>interfaz gráfica</strong></a>. dicha interfaz gráfica necesitará que tu proyecto lo tengas ordenado de esta manera.</p>

<p>Para terminar te dejamos la estructura del directorio de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── Inc
</span><span class='line'>│   ├── main.h
</span><span class='line'>│   ├── stm32f0xx_hal_conf.h
</span><span class='line'>│   └── stm32f0xx_it.h
</span><span class='line'>├── makefile
</span><span class='line'>├── Output/
</span><span class='line'>├── Src
</span><span class='line'>│   ├── main.c
</span><span class='line'>│   ├── stm32f0xx_hal_msp.c
</span><span class='line'>│   ├── stm32f0xx_it.c
</span><span class='line'>│   └── system_stm32f0xx.c
</span><span class='line'>├── startup_stm32f072xb.s
</span><span class='line'>└── STM32F072RB_FLASH.ld</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer Programa Con STM32F0Cube (Pt III)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/10/primer-programa-con-stm32f0cube/"/>
    <updated>2014-08-10T13:30:28-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/10/primer-programa-con-stm32f0cube</id>
    <content type="html"><![CDATA[<p>En los dos anteriores post de la serie <strong>Primer Programa</strong> hemos estado utilizando archivos pertenecientes a la librería <strong>STM32F0Cube</strong>. Esta librería es un banco de código de funciones ya preestablecidas que nos permitirán empezar a codificar nuestras aplicaciones sin conocer tan a detalle el micro que estemos usando.</p>

<p>Llegó la hora de usar a fondo y sacar provecho de esas funciones, vamos a repetir el anterior ejemplo pero esta ocasión sacando provecho a librería <strong>STM32F0Cube</strong>.</p>

<p>Creamos una nueva carpeta para nuestro proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072_cube</span></code></pre></td></tr></table></div></figure>


<p>De nueva cuenta deberás copiar a la carpeta de tu proyecto el archivo linker. Recuerda lo obtienes de la librería de <strong>ST</strong> en la siguiente ruta</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/TrueSTUDIO/STM32F072RB-Nucleo/STM32F072RB_FLASH.ld</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Antes de comenzar, aclararemos que la librería es un conjunto de piezas de código que nos permitirán controlar por completo los periféricos de nuestro microcontrolador y esta diseñada para ser compatible con la totalidad de la línea de micros <strong>STM32F0</strong> de la marca <strong>ST</strong>. Estos codigos no sera necesario que los modifiques o adaptes excepto por un archivo en especial.</p>

<p>Copia el archivo <strong>stm32f0xx_hal_conf_template.h</strong> que encontrarás en la siguiente ruta. Deberas quitarle la proteccion contra escritura y renombrarlo a <strong>stm32f0xx_hal_conf.h</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_conf_template.h</span></code></pre></td></tr></table></div></figure>


<p>Con este archivo podremos controlar varias funciones de los drivers de bajo nivel ( <em>HAL drivers</em> ) de la librería. Una de las cosas que podemos controlar es la cantidad de drivers que vamos a usar</p>

<p>Deberas copiar otros 2 archivos mas, que aunque estos no los vas a modificar ( <em>excepto por un pequeño detalle</em> ) es necesario tenerlos en la carpeta de tu proyecto.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Source/Templates/gcc/startup_stm32f072xb.s
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Source/Templates/system_stm32f0xx.c</span></code></pre></td></tr></table></div></figure>


<p>Agregamos la siguiente linea al archivo <strong>system_stm32f0xx.c</strong>. Lo abrimos con nuestro editor de texto y escribimos lo siguiente en la <strong>linea 85</strong>.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>system_stm32f0xx.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f0xx_hal_conf.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y apartir de la <strong>linea 110</strong> escribimos.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>system_stm32f0xx.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#if !defined  (HSI48_VALUE)</span>
</span><span class='line'>    <span class="cp">#define HSI48_VALUE ((uint32_t)48000000)</span><span class="cm">/*!&lt; Default value of the Internal USB oscillator in Hz.</span>
</span><span class='line'><span class="cm">                                             This value can be provided and adapted by the user application. */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para facilitarnos un poco más las cosas copiamos por completo la carpeta de la libreria <strong>STM32F0Cube</strong> al folder de nuestro proyecto</p>

<p>Como en anteriores ocasiones creamos nuestra carpeta <strong>Output</strong> donde guardaremos los archivos que nos arroja la compilación</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir test_f072_cube/Output</span></code></pre></td></tr></table></div></figure>


<p>Creamos el archivo que contendrá nuestro código magico =).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072_cube/main.c</span></code></pre></td></tr></table></div></figure>


<p>Abrimos con nuestro editor de texto favorito el archivo <strong>main.c</strong> y escribimos el siguiente código</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>Hola Mundo STM32F0Cube - main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f0xx.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">GPIO_InitTypeDef</span>  <span class="n">GPIO_InitStruct</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">HAL_Init</span><span class="p">();</span> <span class="cm">/*init HAL library and tick interrupt to 1 ms*/</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* -1- Enable each GPIO Clock (to be able to program the configuration registers) */</span>
</span><span class='line'>    <span class="n">__GPIOA_CLK_ENABLE</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* -2- Configure IOs in output push-pull mode to drive external LEDs */</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span>  <span class="o">=</span> <span class="n">GPIO_MODE_OUTPUT_PP</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pull</span>  <span class="o">=</span> <span class="n">GPIO_PULLUP</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Speed</span> <span class="o">=</span> <span class="n">GPIO_SPEED_HIGH</span><span class="p">;</span>
</span><span class='line'>    <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span>   <span class="o">=</span> <span class="n">GPIO_PIN_5</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* -3- Toggle IOs in an infinite loop */</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">HAL_GPIO_TogglePin</span><span class="p">(</span><span class="n">GPIOA</span><span class="p">,</span> <span class="n">GPIO_PIN_5</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* Insert delay 100 ms */</span>
</span><span class='line'>        <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">SysTick_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">HAL_IncTick</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>El anterior programa hará parpadear el led de la tarjeta conectado al <strong>puerto A pin 5</strong>. Pero en esta tercera ocasión usando las funciones de la librería <strong>STM32F0Cube</strong>. Como pudes observar en ningún momento accedemos directamente a los registros del microcontrolador.</p>

<p>No entraremos en detalles (<em>aun</em>) con las funciones que encontrarás en el código ( <em>eso lo haremos más adelante</em> ). Por cierto por ahora el archivo  <strong>stm32f0xx_hal_conf.h</strong> no necesitara modificaciones.</p>

<p>Solo nos falta crear el archivo makefile para que make realice la compilación.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch test_f072_cube/makefile</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo en tu editor de texto y escribe el siguiente código. Recuerda usar TABs y no espacios para las indentación.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>makefile </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="nv">PROJECT</span> <span class="o">=</span> <span class="nb">test</span>
</span><span class='line'>
</span><span class='line'><span class="c"># archivos a compilar</span>
</span><span class='line'><span class="nv">FILES</span> <span class="o">=</span> main.o startup_stm32f072xb.o system_stm32f0xx.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_rcc.o stm32f0xx_hal_rcc_ex.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_gpio.o <span class="se">\</span>
</span><span class='line'>stm32f0xx_hal_cortex.o <span class="se">\</span>
</span><span class='line'><span class="err">stm32f0xx_hal_flash.o</span>
</span><span class='line'>
</span><span class='line'><span class="c"># definiciones de control</span>
</span><span class='line'><span class="nv">DEFINES</span> <span class="o">=</span> -DSTM32F072xB -DUSE_HAL_DRIVER
</span><span class='line'>
</span><span class='line'><span class="c"># directorios con archivos fuente (*.c y *.s)</span>
</span><span class='line'><span class="nv">VPATH</span> <span class="o">=</span> STM32Cube_FW_F0_V1.0.0/Drivers/STM32F0xx_HAL_Driver/Src
</span><span class='line'>
</span><span class='line'><span class="c"># directorios con archivos headers (*.h)</span>
</span><span class='line'><span class="nv">INCLUDE</span> <span class="o">=</span> -I ./ <span class="se">\</span>
</span><span class='line'>-I STM32Cube_FW_F0_V1.0.0/Drivers/STM32F0xx_HAL_Driver/Inc <span class="se">\</span>
</span><span class='line'>-I STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Include <span class="se">\</span>
</span><span class='line'><span class="err">-I</span> <span class="err">STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include</span>
</span><span class='line'>
</span><span class='line'><span class="c"># a partir de aquí no modifiques nada a menos que sepas lo que haces</span>
</span><span class='line'><span class="c"># linker script to be use</span>
</span><span class='line'><span class="nv">LINKERFILE</span> <span class="o">=</span> STM32F072RB_FLASH.ld
</span><span class='line'><span class="nv">CPU</span> <span class="o">=</span> -mcpu<span class="o">=</span>cortex-m0 -mthumb -mlittle-endian
</span><span class='line'>
</span><span class='line'><span class="nv">AS</span> <span class="o">=</span> arm-none-eabi-as
</span><span class='line'><span class="nv">CC</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">LD</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">OD</span> <span class="o">=</span> arm-none-eabi-objdump
</span><span class='line'><span class="nv">OC</span> <span class="o">=</span> arm-none-eabi-objcopy
</span><span class='line'>
</span><span class='line'><span class="nv">CCFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> <span class="k">$(</span>DEFINES<span class="k">)</span> <span class="k">$(</span>INCLUDE<span class="k">)</span> -Wall -fno-common -O0 -fomit-frame-pointer -Wstrict-prototypes -fverbose-asm
</span><span class='line'><span class="nv">ASFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span>
</span><span class='line'><span class="nv">LDFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> -Wl,--gc-sections
</span><span class='line'><span class="nv">OCFLAGS</span> <span class="o">=</span> -Oihex
</span><span class='line'><span class="nv">ODFLAGS</span> <span class="o">=</span> -S
</span><span class='line'>
</span><span class='line'><span class="nf">all </span><span class="o">:</span> <span class="n">test</span>
</span><span class='line'>
</span><span class='line'><span class="nf">test </span><span class="o">:</span> <span class="k">$(</span><span class="nv">PROJECT</span><span class="k">)</span>.<span class="n">elf</span>
</span><span class='line'>    <span class="k">$(</span>OC<span class="k">)</span> <span class="k">$(</span>OCFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf <span class="k">$(</span>PROJECT<span class="k">)</span>.hex
</span><span class='line'>    <span class="k">$(</span>OD<span class="k">)</span> <span class="k">$(</span>ODFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf &gt; <span class="k">$(</span>PROJECT<span class="k">)</span>.lst
</span><span class='line'>    mv *.o *.elf *.hex *.lst Output
</span><span class='line'>
</span><span class='line'><span class="nf">$(PROJECT).elf </span><span class="o">:</span> <span class="k">$(</span><span class="nv">FILES</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -T<span class="k">$(</span>LINKERFILE<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile C source files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CCFLAGS<span class="k">)</span> -c -g -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile ASM files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>    <span class="k">$(</span>AS<span class="k">)</span> <span class="k">$(</span>ASFLAGS<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean </span><span class="o">:</span>
</span><span class='line'>    rm Output/*.*
</span></code></pre></td></tr></table></div></figure>


<p>En esta ocasión compilamos varios archivos fuente y tenemos un directorio con la librería completa de <strong>ST</strong>.</p>

<p>A compilar se ha dicho</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cube
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>Si la terminal no arrojo ningun error deberemos tener nuestro archivo <strong>test.hex</strong> en la carpeta Output</p>

<h2>A Programar se ha dicho</h2>

<p>Abre una nueva terminal y conectate con tu tarjeta usando OpenOCD</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cube  #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<p>En la terminal anterior madaremos nuestro programa compilado a nuestra tarjeta usando <strong>telnet</strong>, conectate al puerto <strong>4444</strong> de la siguiente manera</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_cube #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ telnet localhost 4444</span></code></pre></td></tr></table></div></figure>


<p>Si te acepta la conexion, solo restara mandar el archivo <strong>.hex</strong>. Escribe los siguientes comandos en orden</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset halt
</span><span class='line'>flash write_image erase Output/test.hex
</span><span class='line'>reset run</span></code></pre></td></tr></table></div></figure>


<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Conclusion</h2>

<p>Incluir la librería completa de <strong>ST</strong> nos ayuda a no tener que conocer a fondo cómo funcionan los periféricos del microcontrolador, ahora solo tendremos que conocer a fondo cómo funciona la librería =). En general tener una librería como la <strong>STM32F0Cube</strong> representa una gran ventaja en especial si tomamos en cuenta que es compatible con toda la linea de micros de la familia <strong>STM32F0</strong>.</p>

<p>Solo hay que poner un poco de esfuerzo en como configurar los códigos e indicarle de manera correcta los directorios de los archivos fuente al compilador, costará un poco de trabajo al principio pero despues te acostumbras.</p>

<p>Para terminar te dejamos la estructura del directorio de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── main.c
</span><span class='line'>├── makefile
</span><span class='line'>├── Output/
</span><span class='line'>├── STM32Cube_FW_F0_V1.0.0/
</span><span class='line'>├── STM32F072RB_FLASH.ld
</span><span class='line'>├── stm32f0xx_hal_conf.h
</span><span class='line'>├── startup_stm32f072xb.s
</span><span class='line'>└── system_stm32f0xx.c</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer Programa CMSIS (Pt II)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/08/primer-programa-cmsis/"/>
    <updated>2014-08-08T13:07:34-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/08/primer-programa-cmsis</id>
    <content type="html"><![CDATA[<p>En el post <a href="http://testdiego.github.io/blog/2014/08/06/primer-programa-bare-board/"><strong>Primer Programa Bare Board</strong></a> aprendimos como correr nuestro primer programa sin la ayuda de libreria y función alguna ( <em>excepto el startup y el linker file</em> ). En esta ocasión usaremos la definición de registros acorde al estándar <strong>CMSIS</strong>.</p>

<p><strong>CMSIS</strong> nos ayudará a acceder a los registros del micro de una forma más cómoda y organizada, además es un estándar difundido entre los fabricantes de micros con CPUs <strong>ARM</strong>,</p>

<p>Creamos una nueva carpeta para nuestro proyecto con <strong>CMSIS</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072_CMSIS</span></code></pre></td></tr></table></div></figure>


<p>De nueva cuenta deberás copiar a la carpeta de tu proyecto el archivo linker. Recuerda lo obtienes de la librería de ST en la siguiente ruta</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/TrueSTUDIO/STM32F072RB-Nucleo/STM32F072RB_FLASH.ld</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Crea una nueva carpeta en tu proyecto llamada <strong>system</strong> en la cual colocaremos los archivos CMSIS</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072_CMSIS/system</span></code></pre></td></tr></table></div></figure>


<p>Copia en esta nueva carpeta los siguientes archivos, los cuales los encontrarás en la librería de ST en la siguientes rutas</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Source/Templates/gcc/startup_stm32f072xb.s
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Source/Templates/system_stm32f0xx.c
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Include/system_stm32f0xx.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include/arm_math.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include/core_cm0.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include/core_cmFunc.h
</span><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Include/core_cmInstr.h</span></code></pre></td></tr></table></div></figure>


<p>Antes de seguir avanzando, aclararemos que al archivo <strong>startup</strong> no le haremos ninguna modificación y que los archivos <strong>system</strong> nos permiten inicializar algunas pequeñas cosas del micro, como los relojes de las memorias.</p>

<p>Al que si modificaremos es al archivo <strong>system_stm32f0xx.c</strong>, Lo abrimos con nuestro editor de texto y escribimos lo siguiente apartir de la <strong>linea 110</strong>.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>system_stm32f0xx.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#if !defined  (HSI48_VALUE)</span>
</span><span class='line'>    <span class="cp">#define HSI48_VALUE ((uint32_t)48000000)</span><span class="cm">/*!&lt; Default value of the Internal USB oscillator in Hz.</span>
</span><span class='line'><span class="cm">                                             This value can be provided and adapted by the user application. */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>y modificamos la <strong>linea 84</strong> de la siguiente manera</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>system_stm32f0xx.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f072xb.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Creamos nuestra carpeta <strong>Output</strong> donde guardaremos los archivos que nos arroja la compilación</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir test_f072_CMSIS/Output</span></code></pre></td></tr></table></div></figure>


<p>Creamos el archivo que contendrá nuestro código magico =).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072_CMSIS/main.c</span></code></pre></td></tr></table></div></figure>


<p>Abrimos con nuestro editor de texto favorito el archivo <strong>main.c</strong> y escribimos el siguiente código</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>Hola Mundo CMSIS - main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;stm32f072xb.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define LED_PIN 5</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Enable GPIOA clock */</span>
</span><span class='line'>    <span class="n">RCC</span><span class="o">-&gt;</span><span class="n">AHBENR</span> <span class="o">|=</span> <span class="n">RCC_AHBENR_GPIOAEN</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 as output */</span>
</span><span class='line'>    <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">MODER</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 in max speed */</span>
</span><span class='line'>    <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span><span class="p">(;;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Toggle pin 5 from port A */</span>
</span><span class='line'>        <span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">ODR</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LED_PIN</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* simple and practical delay */</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">300000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>El anterior programa hará parpadear el led de la tarjeta conectado al <strong>puerto A pin 5</strong>. A diferencia del anterior post en este código no usamos las direcciones de los registros directamente, sino que usamos la definición de registros, lo cual es mucho más práctico.</p>

<p>Estos registros los encuentras definidos en el archivo <strong>stm32f072xb.h</strong>. Las definiciones son simples punteros a estructuras y esto es así porque lo dicta el estándar CMSIS <code>[Periferico]-&gt;[registro]</code>.</p>

<p>Solo nos falta crear el archivo makefile para que make realice la compilación.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch test_f072_CMSIS/makefile</span></code></pre></td></tr></table></div></figure>


<p>Abre el archivo en tu editor de texto y escribe el siguiente código. Recuerda usar TABs y no espacios para las indentación.</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>makefile </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="c">#Nombre que desees para tu proyecto</span>
</span><span class='line'><span class="nv">PROJECT</span> <span class="o">=</span> <span class="nb">test</span>
</span><span class='line'>
</span><span class='line'><span class="c">#archivos a compilar</span>
</span><span class='line'><span class="nv">FILES</span> <span class="o">=</span> main.o startup_stm32f072xb.o system_stm32f0xx.o
</span><span class='line'>
</span><span class='line'><span class="c">#directorio con archivos a compilar (*.c, *.s)</span>
</span><span class='line'><span class="nv">VPATH</span> <span class="o">=</span> system
</span><span class='line'>
</span><span class='line'><span class="c">#directorio con archivos headers (*.h)</span>
</span><span class='line'><span class="nv">INCLUDES</span> <span class="o">=</span> -I system
</span><span class='line'>
</span><span class='line'><span class="c"># Apartir de aqui no modifiques nada a menos que sepas lo que hases. ;)</span>
</span><span class='line'><span class="c"># linker script a usar</span>
</span><span class='line'><span class="nv">LINKERFILE</span> <span class="o">=</span> STM32F072RB_FLASH.ld
</span><span class='line'><span class="nv">CPU</span> <span class="o">=</span> -mcpu<span class="o">=</span>cortex-m0 -mthumb -mlittle-endian
</span><span class='line'>
</span><span class='line'><span class="nv">AS</span> <span class="o">=</span> arm-none-eabi-as
</span><span class='line'><span class="nv">CC</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">LD</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">OD</span> <span class="o">=</span> arm-none-eabi-objdump
</span><span class='line'><span class="nv">OC</span> <span class="o">=</span> arm-none-eabi-objcopy
</span><span class='line'>
</span><span class='line'><span class="nv">CCFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> <span class="k">$(</span>INCLUDES<span class="k">)</span> -Wall -fno-common -O0 -fomit-frame-pointer -Wstrict-prototypes -fverbose-asm
</span><span class='line'><span class="nv">ASFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span>
</span><span class='line'><span class="nv">LDFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> -Wl,--gc-sections
</span><span class='line'><span class="nv">OCFLAGS</span> <span class="o">=</span> -Oihex
</span><span class='line'><span class="nv">ODFLAGS</span> <span class="o">=</span> -S
</span><span class='line'>
</span><span class='line'><span class="nf">all </span><span class="o">:</span> <span class="n">test</span>
</span><span class='line'>
</span><span class='line'><span class="nf">test </span><span class="o">:</span> <span class="k">$(</span><span class="nv">PROJECT</span><span class="k">)</span>.<span class="n">elf</span>
</span><span class='line'>    <span class="k">$(</span>OC<span class="k">)</span> <span class="k">$(</span>OCFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf <span class="k">$(</span>PROJECT<span class="k">)</span>.hex
</span><span class='line'>    <span class="k">$(</span>OD<span class="k">)</span> <span class="k">$(</span>ODFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf &gt; <span class="k">$(</span>PROJECT<span class="k">)</span>.lst
</span><span class='line'>    mv *.o *.elf *.hex *.lst Output
</span><span class='line'>
</span><span class='line'><span class="nf">$(PROJECT).elf </span><span class="o">:</span> <span class="k">$(</span><span class="nv">FILES</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -T<span class="k">$(</span>LINKERFILE<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile C source files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CCFLAGS<span class="k">)</span> -c -g -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile ASM files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>    <span class="k">$(</span>AS<span class="k">)</span> <span class="k">$(</span>ASFLAGS<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean </span><span class="o">:</span>
</span><span class='line'>    rm Output/*.*
</span></code></pre></td></tr></table></div></figure>


<p>En esta ocasión compilamos tres archivos fuente y tenemos un subfolder el cual hay que indicarle al compilador.</p>

<p>A compilar se ha dicho</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>Si la terminal no arrojo ningun error deberemos tener nuestro archivo <strong>test.hex</strong> en la carpeta Output</p>

<h2>A Programar se ha dicho</h2>

<p>Abre una nueva terminal y conectate con tu tarjeta usando OpenOCD</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS  #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<p>En la terminal anterior madaremos nuestro programa compilado a nuestra tarjeta usando <strong>telnet</strong>, conectate al puerto <strong>4444</strong> de la siguiente manera</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072_CMSIS #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ telnet localhost 4444</span></code></pre></td></tr></table></div></figure>


<p>Si te acepta la conexion, solo restara mandar el archivo <strong>.hex</strong>. Escribe los siguientes comandos en orden</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset halt
</span><span class='line'>flash write_image erase Output/test.hex
</span><span class='line'>reset run</span></code></pre></td></tr></table></div></figure>


<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Conclusion</h2>

<p>Incluir los archivos que nos indica el estándar <strong>CMSIS</strong> nos facilita la interacción con los registros del sistema, pero eso no es lo unico ya que tambien nos permitira de una forma mas sencilla llamar las funciones de interrupción y controlar los registros internos del CPU.</p>

<p>Lo único que no nos exenta es el hecho de configurar los periféricos del micro de manera manual sin la ayuda de ningún framework o librería.</p>

<p>Para terminar te dejamos la estructura del directorio de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── main.c
</span><span class='line'>├── makefile
</span><span class='line'>├── Output/
</span><span class='line'>├── STM32F072RB_FLASH.ld
</span><span class='line'>└── System/
</span><span class='line'>    ├── arm_math.h
</span><span class='line'>    ├── core_cm0.h
</span><span class='line'>    ├── core_cmFunc.h
</span><span class='line'>    ├── core_cmInstr.h
</span><span class='line'>    ├── startup_stm32f072xb.s
</span><span class='line'>    ├── stm32f072xb.h
</span><span class='line'>    ├── system_stm32f0xx.c
</span><span class='line'>    └── system_stm32f0xx.h
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer Programa Bare Board (Pt I)]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/06/primer-programa-bare-board/"/>
    <updated>2014-08-06T16:17:22-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/06/primer-programa-bare-board</id>
    <content type="html"><![CDATA[<p>Con nuestro compilador instalado y <strong>OpenOCD</strong> listo para comunicarse con nuestra tarjeta <strong>Nucleo-F072RB</strong>, llego la hora de crear nuestro programa <em>hola mundo</em>. Antes que nada aclararemos que no usaremos ningun IDE en especifico, para escribir el codigo usaremos cualquier editor de texto plano ( <em>te recomiendo Sublime Text</em> ) y la compilacion la realizaremos usando archivos <strong>makefiles</strong> y la <strong>terminal</strong>.</p>

<p>El programa lo realizaremos sin el uso de ninguna libreria de funciones ( <em>just balls!!!</em> ), pero si nesecitaremos un par de archivos de apoyo y los optendremos de la libreria oficial <a href="http://www.st.com/web/en/catalog/tools/PF260612"><strong>STM32F0Cube</strong></a> de ST. Descarga el archivo y descomprimelo en tu lugar favorito de la computadora =).</p>

<p>Crea una carpeta donde estara tu flamante y nuevo programa de prueba</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072
</span><span class='line'>$ cd ~/test_f072</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Copia a la carpeta de tu proyecto el archivo <strong>linker</strong>, el cual permitira a tu programa saber como esta ordenada la memoria del micro. El archivo se encuentra en la libreria de <strong>ST</strong> en la siguiente ruta:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Projects/STM32F072RB-Nucleo/Templates/TrueSTUDIO/STM32F072RB-Nucleo/STM32F072RB_FLASH.ld</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Copia a la carpeta de tu proyecto el archivo <strong>startup</strong> el cual permitira a tu programa entre otras cosas iniciar desde el vector de reset, setear el valor del stack pointer y acomodar la tabla de vectores de interrupciones del micro. EL archivo se encuentra en la libreria de <strong>ST</strong> en la siguiente ruta:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STM32Cube_FW_F0_V1.0.0/Drivers/CMSIS/Device/ST/STM32F0xx/Source/Templates/gcc/startup_stm32f072xb.s</span></code></pre></td></tr></table></div></figure>


<p>Habra que hacer una pequeña modificacion al archivo de <strong>startup_stm32f072xb.s</strong> para que no nos de problema con una funcion que manda llamar ( <em>y que por lo pronto no tenemos</em> ). Abre con tu editor favorito el archivo y comenta la linea numero <strong>101</strong>. <em>Al archivo le deberas quitar la proteccion contra escritura para realizar lo anterior</em>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>100 /* Call the clock system intitialization function.*/
</span><span class='line'>101    //bl  SystemInit
</span><span class='line'>102 /* Call static constructors */</span></code></pre></td></tr></table></div></figure>


<p>En el directorio de tu proyecto crea una carpeta a la que llamaremos <strong>Output</strong> y sera la carpeta en la que dejaremos los archivos producidos por la compilacion</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/test_f072/Output</span></code></pre></td></tr></table></div></figure>


<p>Bien hora de la accion, crea un nuevo archivo al que llamremos <strong>main.c</strong> y que contendra nuestro codigo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072/main.c</span></code></pre></td></tr></table></div></figure>


<h2>Escribiendo el codigo</h2>

<p>Abre el archivo con tu editor de texto favorito ( <em>como Gedit</em> ) y escribe el siguiente codigo</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>Hola Mundo - main.c </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define LED_PIN 5</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Enable clock for GPIO port A */</span>
</span><span class='line'>    <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="mh">0x40021014</span><span class="p">)</span> <span class="o">|=</span> <span class="mh">0x00020000</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 as output */</span>
</span><span class='line'>    <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="mh">0x48000000</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="cm">/* Configure GPIOA pin 5 in max speed */</span>
</span><span class='line'>    <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="mh">0x48000008</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LED_PIN</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span><span class="p">(;;)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Toggle pin 5 from port A */</span>
</span><span class='line'>        <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="mh">0x48000014</span><span class="p">)</span> <span class="o">^=</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LED_PIN</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* simple and practical delay */</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>El anterior codigo solo hara parpadear el led conectado al <strong>puerto A pin 5</strong>, el cual esta presente en la tarjeta. Y te estaras preguntando que son todos esos numeros??, pues son las direcciones en las que se encuntran los registros que deberemos manipular para interactuar con el <strong>pin A5</strong>. Esta informcaion la optienes de la hoja de datos del micro.</p>

<p>Hora de compilar nuestro programa. La compilacion la realizaremos usando un archivo <strong>makefile</strong> el cual concentrara las ordenes de compilacion que le pasaremos a nuestro toolchain.</p>

<p>Crea un nuevo archivo llamado makefile en la carpeta de tu proeycto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch ~/test_f072/makefile</span></code></pre></td></tr></table></div></figure>


<p>Abre este nuevo archivo con tu editor de texto favorito ( <em>digamos atom</em> ) y escribe lo siguiente</p>

<figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>makefile </h3></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="c"># Nombre que desees para tu proyecto</span>
</span><span class='line'><span class="nv">PROJECT</span> <span class="o">=</span> <span class="nb">test</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Archivos fuente a compilar</span>
</span><span class='line'><span class="nv">FILES</span> <span class="o">=</span> main.o startup_stm32f072xb.o
</span><span class='line'>
</span><span class='line'><span class="c"># Apartir de aqui no modifiques nada a menos que sepas lo que hases. ;)</span>
</span><span class='line'><span class="c"># linker script a usar</span>
</span><span class='line'><span class="nv">LINKERFILE</span> <span class="o">=</span> STM32F072RB_FLASH.ld
</span><span class='line'><span class="nv">CPU</span> <span class="o">=</span> -mcpu<span class="o">=</span>cortex-m0 -mthumb -mlittle-endian
</span><span class='line'>
</span><span class='line'><span class="nv">AS</span> <span class="o">=</span> arm-none-eabi-as
</span><span class='line'><span class="nv">CC</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">LD</span> <span class="o">=</span> arm-none-eabi-gcc
</span><span class='line'><span class="nv">OD</span> <span class="o">=</span> arm-none-eabi-objdump
</span><span class='line'><span class="nv">OC</span> <span class="o">=</span> arm-none-eabi-objcopy
</span><span class='line'>
</span><span class='line'><span class="nv">CCFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> -Wall -fno-common -O0 -fomit-frame-pointer -Wstrict-prototypes -fverbose-asm
</span><span class='line'><span class="nv">ASFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span>
</span><span class='line'><span class="nv">LDFLAGS</span> <span class="o">=</span> <span class="k">$(</span>CPU<span class="k">)</span> -Wl,--gc-sections
</span><span class='line'><span class="nv">OCFLAGS</span> <span class="o">=</span> -Oihex
</span><span class='line'><span class="nv">ODFLAGS</span> <span class="o">=</span> -S
</span><span class='line'>
</span><span class='line'><span class="nf">all </span><span class="o">:</span> <span class="n">test</span>
</span><span class='line'>
</span><span class='line'><span class="nf">test </span><span class="o">:</span> <span class="k">$(</span><span class="nv">PROJECT</span><span class="k">)</span>.<span class="n">elf</span>
</span><span class='line'>    <span class="k">$(</span>OC<span class="k">)</span> <span class="k">$(</span>OCFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf <span class="k">$(</span>PROJECT<span class="k">)</span>.hex
</span><span class='line'>    <span class="k">$(</span>OD<span class="k">)</span> <span class="k">$(</span>ODFLAGS<span class="k">)</span> <span class="k">$(</span>PROJECT<span class="k">)</span>.elf &gt; <span class="k">$(</span>PROJECT<span class="k">)</span>.lst
</span><span class='line'>    mv *.o *.elf *.hex *.lst Output
</span><span class='line'>
</span><span class='line'><span class="nf">$(PROJECT).elf </span><span class="o">:</span> <span class="k">$(</span><span class="nv">FILES</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -T<span class="k">$(</span>LINKERFILE<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile C source files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CCFLAGS<span class="k">)</span> -c -g -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Compile ASM files</span>
</span><span class='line'><span class="nf">%.o </span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>    <span class="k">$(</span>AS<span class="k">)</span> <span class="k">$(</span>ASFLAGS<span class="k">)</span> -o <span class="nv">$@</span> <span class="nv">$^</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean </span><span class="o">:</span>
</span><span class='line'>    rm Output/*.*
</span></code></pre></td></tr></table></div></figure>


<p>No te apures si no sabes nada de <strong>makefiles</strong>, dentro de poco posteare un par de tutoriales. Otra cosa muy importante cuando escribes lo anterior usa <strong>TABS</strong> en la identacion y no espacios, o tendras errores.</p>

<p>Uff!!. Hora de compilar, solo escribe <strong>make</strong> en tu terminal, recuerda estar en la carpeta de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072
</span><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>Si la terminal no te arrojo ningun error de compilacion deberas tener un archivo <strong>test.hex</strong> en tu folder <strong>Output</strong>, anda ve y revisa, porque hay que programar la tarjeta</p>

<h2>A Programar se ha dicho</h2>

<p>Abre una nueva terminal y conectate con tu tarjeta usando OpenOCD</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072  #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<p>En la terminal anterior madaremos nuestro programa compilado a nuestra tarjeta usando <strong>telnet</strong>, conectate al puerto <strong>4444</strong> de la siguiente manera</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/test_f072 #Recomendacion, siempre estar en el directorio de tu proyecto
</span><span class='line'>$ telnet localhost 4444</span></code></pre></td></tr></table></div></figure>


<p>Si te acepta la conexion, solo restara mandar el archivo <strong>.hex</strong>. Escribe los siguientes comandos en orden</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reset halt
</span><span class='line'>flash write_image erase Output/test.hex
</span><span class='line'>reset run</span></code></pre></td></tr></table></div></figure>


<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el ultimo lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<p>Esta manera de programar ( <em>sin ayuda alguna</em> ) te obligara a leer bien la hoja de datos del micro y en consecuencia aprenderas muy bien a utilizar la maquina que estas usando, pero te costara buenas desveladas y canas verdes.</p>

<p>Para terminar te dejamos la estructura del directorio de tu proyecto</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── main.c
</span><span class='line'>├── makefile
</span><span class='line'>├── Output/
</span><span class='line'>├── startup_stm32f072xb.s
</span><span class='line'>├── STM32F072RB_FLASH.ld
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/06/instalando-openocd/"/>
    <updated>2014-08-06T11:54:37-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/06/instalando-openocd</id>
    <content type="html"><![CDATA[<p>Ya con el compilador instalado, deberemos instalar un programa que nos permita comunicarnos con nuestro hardware y programarlo. Para ello usaremos <strong>OpenOCD</strong>, el cual es un pequeño servidor que se conectará con nuestro programador/debugger y nos permitirá pasar a nuestro micro el programa ya compilado.</p>

<p><strong>NOTA</strong> Necesitamos instalar unas pequeñas librerias a manera de prerequisito (drivers USB). En Ubuntu escribe</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install libftdi-dev libusb-1.0-0-dev</span></code></pre></td></tr></table></div></figure>


<p><strong>OpenOCD</strong> es un software totalmente libre y en constante actualización, descarga la versión <strong>0.8.0</strong> de <a href="http://sourceforge.net/projects/openocd/files/openocd/0.8.0/"><strong>Aquí</strong></a>.</p>

<p>Descomprime el archivo descargado con el siguiente comando en la terminal.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar xvjf openocd-0.8.0.tar.bz2</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p><strong>OpenOCD</strong> se distribuye usando sus archivos fuente, así que antes de ejecutarlo debemos compilarlo y despues instalarlo. No te preocupes son pasos muy sencillos.</p>

<p>Primero pasate a la carpeta de OpenOCD ya descomprimido</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd openocd-0.8.0 </span></code></pre></td></tr></table></div></figure>


<p>Ahora lo configuraremos para que trabaje con ciertos debuggers, como <strong>jlink</strong>, <strong>ftdi</strong> y <strong>stlink</strong> ( <em>que es el que usaremos nosotros</em> )</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./configure --enable-stlink --enable-jlink --enable-ftdi</span></code></pre></td></tr></table></div></figure>


<p>Compilamos</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make</span></code></pre></td></tr></table></div></figure>


<p>Por último instalamos</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo make install</span></code></pre></td></tr></table></div></figure>


<p><strong>OpenOCD</strong> quedó instalado en dos diferentes folders de nuestro sistema linux, el ejecutable ( <em>binario</em> ) quedará en el directorio <code>/usr/local/bin</code>.</p>

<p>La otra carpeta importante <code>/usr/local/share/openocd/scripts</code> es donde quedarán instalados los scripts que nos servirán para identificar el micro que queremos programar y contiene la información necesaria para decirle a <strong>OpenOCD</strong> como programarlo, estos scripts están agrupados en tres niveles:</p>

<ul>
<li><strong>target.-</strong> scripts con instrucciones especificas para microcontroladores/procesadores</li>
<li><strong>interface.-</strong> scripts con la informacion del debugger/programador a usar</li>
<li><strong>board.-</strong> scripts con instrucciones que combinan interface y target. Y pertenecen a tarjetas especifcas que ya estan en el mercado</li>
</ul>


<p>Antes de prenderle fuego a tu board ( <em>conectarla a OpenOCD</em> ) deberemos registrar ciertas reglas, para que el debugger ( <em>ST-Link-V2-1</em> ) sea reconocido por nuestro sistema. Para no entrar mas en detallas simplemente ejecuta lo siguietne en la terminal.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo cp  /usr/local/share/openocd/contrib/openocd.udev  /etc/udev/rules.d/98-openocd.rules
</span><span class='line'>$ sudo udevadm control --reload-rules</span></code></pre></td></tr></table></div></figure>


<p>Bueno basta de Charla, hay que probar si realmente funciona. Para ello usaremos nuestra nueva tarjeta <strong>Nucleo-F072RB</strong> de la marca <strong>ST</strong>, el cual por cierto posee un micro con CPU <strong>Cortex-M0</strong>. Conectala al puerto USB ( <em>se abrirá una ventana, pues la PC la identificara como un mass storage, no te apures solo cierra la ventana</em> )</p>

<p>En la terminal ejecuta OpenOCD de la siguiente manera.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg</span></code></pre></td></tr></table></div></figure>


<p>Si todo resulto bien te aparecera la siguiente información.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Open On-Chip Debugger 0.8.0 (2014-08-02-17:39)
</span><span class='line'>Licensed under GNU GPL v2
</span><span class='line'>For bug reports, read
</span><span class='line'>    http://openocd.sourceforge.net/doc/doxygen/bugs.html
</span><span class='line'>Info : This adapter doesn't support configurable speed
</span><span class='line'>Info : STLINK v2 JTAG v22 API v2 SWIM v5 VID 0x0483 PID 0x374B
</span><span class='line'>Info : using stlink api v2
</span><span class='line'>Info : Target voltage: 3.246689
</span><span class='line'>Info : stm32f0x.cpu: hardware has 4 breakpoints, 2 watchpoints</span></code></pre></td></tr></table></div></figure>


<p>Con un <code>Ctrl+C</code> sales de openocd.</p>

<p>Si requieres mas informacion consulta:</p>

<ul>
<li><a href="openocd.org">openocd.org</a></li>
<li><a href="http://gnuarmeclipse.livius.net/blog/openocd-install/">http://gnuarmeclipse.livius.net/blog/openocd-install/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando El Compilador GNU ARM]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm/"/>
    <updated>2014-08-05T21:52:45-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm</id>
    <content type="html"><![CDATA[<p>Vamos a empezar con nuestro primer post, y consistira en la instalacion y puesta a punto de nuestra herramienta de desarrollo favorita para microcontroladores <strong>ARM</strong>. El compilador <strong>GCC</strong> es totalemnte libre y lo mejor, no presenta limitacion alguna =).</p>

<p>Primero lo primero, Deberas descargar el toolchain de su pagina oficial <a href="https://launchpad.net/gcc-arm-embedded"><strong>aqui</strong></a>. Si usas linux, como yo =) descarga el archivo <strong>Linux Installation Tarball</strong>.</p>

<p>Habre la terminal y crea un nuevo folder en tu directorio de usuario. Es en este directorio donde quedara instalado nuestro compilador.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir ~/ARM</span></code></pre></td></tr></table></div></figure>


<p>Descomprime el archivo descargado en el directorio recien creado (sustituye las x por la version que hayas descargado).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar -xvjf gcc-arm-none-eabi-X_X-xxxxxx-xxxxxxxx-linux.tar.bz2 -C ~/ARM/</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>El siguiente paso es agregar el directorio bin a la variable global <strong>PATH</strong> para que sea ejecutable por la terminal en cualquier directorio.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ nano ~/.bashrc</span></code></pre></td></tr></table></div></figure>


<p>Agrega la siguiente linea al final del archivo, sustituye las <strong>x</strong> con el numero de la version que tengas, fijate en el nombre de la carpeta que descomprimiste.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PATH=$PATH:$HOME/ARM/gcc-arm-none-eabi-X_X-xxxxxx/bin</span></code></pre></td></tr></table></div></figure>


<p>Reinicia la terminal y escribe el siguiente comando que te dira la version del toolchain instalado.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-gcc -v</span></code></pre></td></tr></table></div></figure>


<p>Listo ya tienes tu compilador instalado.</p>
]]></content>
  </entry>
  
</feed>
