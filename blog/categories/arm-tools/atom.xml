<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arm Tools | Diego Blog]]></title>
  <link href="http://testDiego.github.io/blog/categories/arm-tools/atom.xml" rel="self"/>
  <link href="http://testDiego.github.io/"/>
  <updated>2014-08-14T13:24:02-07:00</updated>
  <id>http://testDiego.github.io/</id>
  <author>
    <name><![CDATA[Diego]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programando Con OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/13/programando-con-openocd/"/>
    <updated>2014-08-13T20:39:06-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/13/programando-con-openocd</id>
    <content type="html"><![CDATA[<p>Existen diferentes maneras en que podemos programar nuestro microcontrolador usando <strong>OpenOCD</strong>, ( <em>una muestra de su versatilidad</em> ), y en este nuevo post examinaremos algunas de ellas, quedara en ti escoger la más adecuada para tu sistema de trabajo.</p>

<p>Antes que nada y para simplificar un poco utilizaremos el programa que creamos en el post <a href="http://testdiego.github.io/blog/2014/08/06/primer-programa-bare-board"><strong>Primer Programa Bare Board</strong></a> y daremos por echo que ya esta correctamente compilado y tenemos los archivos tets.elf y test.hex generados en el subfolder Output.</p>

<h2>Usando Telnet</h2>

<p>Esta opción ya la hemos manejado en los anteriores post, pero no está de más incluirla aquí. Primero que nada tendrás que conectarte a tu tarjeta con <strong>OpenOCD</strong>
<code>
$ cd ~/test_f072 #recuerda que debemos estar en alcarpeta del proyecto
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg
</code></p>

<!--more-->


<p>Recuerda que debes indicar la interfaz que manejas ( <em>en este caso stlink</em> ) y el micro a programar ( <em>en este caso stm32f0</em> ). Y eso es lo que se hace en el código de arriba.</p>

<p>Por default <strong>OpenOCD</strong> estará escuchando en el <strong>puerto 4444</strong> para aceptar conexiones por <strong>telnet</strong>, así que lo siguiente es usar el programa <strong>telnet</strong> para conectarnos a ese mismo puerto. En otra terminal escribimos
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ telnet localhost 4444
</code></p>

<p>Notamos como <strong>OpenOCD</strong> nos acepta la conexión, con lo cual estamos listos para mandarle comandos y que este los ejecute. Puedes investigar cuales son los comandos que acepta <strong>OpenOCD</strong> leyendo su manual de usuario.</p>

<p>Para programar la memoria del micro se usarán los siguientes
<code>
reset halt
flash write_image erase Output/test.hex
reset run
exit
</code></p>

<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Usando solo OpenOCD</h2>

<p>Se puede usar únicamente <strong>OpenOCD</strong> sin necesitar de un programa externo como <strong>telnet</strong> para programar el micro. Simplemente le debes pasar algunos comandos a <strong>OpenOCD</strong> al momento de invocarlo
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg -c "program Output/test.hex verify reset"
</code></p>

<p>Si observas bien puedes darte cuenta que con la bandera <code>-c</code> puedes pasar comandos a <strong>OpenOCD</strong>. En este caso le estamos indicando que programe el micro con el archivo <strong>.hex</strong> <code>Output/test.hex</code> y que después de hacer la programación realice una verificación y un reset.</p>

<p>Esta nueva forma hace que <strong>OpenOCD</strong> se conecte a nuestro micro, cargue el programa, lo verifique y ponga correr el programa para después desconectarse de la tarjeta.</p>

<h2>Usando Archivos .cfg con OpenOCD</h2>

<p>El anterior método resultó ser mucho más corto y sencillo que el anterior con <strong>telnet</strong>, pero en contra está la kilométrica línea con la que debemos invocar <strong>OpenOCD</strong> desde la terminal. Lo cual lo hace bastante engorroso y fácil de cometer equivocaciones.</p>

<p>Para evitar lo anterior escribiremos los argumentos con los que invocamos <strong>OpenOCD</strong> en un archivo <code>.cfg</code> ( <em>que son los que entiende OpenOCD</em> ) así que en la misma carpeta de tu proyecto crea el archivo <strong>openocd.cfg</strong>
<code>
$ touch ~/test_f072/openocd.cfg
</code></p>

<p>Abre el archivo recién creado con tu editor de texto favorito y escribe lo siguiente
&#8220;`</p>

<h1>Indicamos que usaremos stlink como programador</h1>

<p>source [find interface/stlink-v2-1.cfg]</p>

<h1>Indicamos que es micro Cortex-M0 de la marca ST</h1>

<p>source [find target/stm32f0x_stlink.cfg]</p>

<h1>Programamos el archivo &ldquo;test.hex&rdquo; que se encuentra en la carpeta</h1>

<h1>Output de nuestro proyecto y despues verificamos y damos un reset</h1>

<p>program Output/test.hex verify reset</p>

<pre><code>
Ahora tenemos los anteriores parámetros escritos en un archivo en la carpeta de nuestro proyecto, con lo cual invocar **OpenOCD** se vuelve mas sencillo. Solo escribimos
</code></pre>

<p>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd -f openocd.cfg
&#8220;`</p>

<p>Como puedes ver a <strong>OpenOCD</strong> lo invocamos pasando el nombre del archivo que contiene los comandos que se deben ejecutar al conectarse a nuestra tarjeta. Un metodo simple y rápido, que nos da pie a crear formas más flexibles de conectarnos y programar nuestros dispositivos.</p>

<h2>Conclusion</h2>

<p>Como puedes ver unas opciones parecen ser mejores que otras. Bueno eso dependerá de la forma que uses <strong>OpenOCD</strong>. Con telnet tienes una opción poderosa para realizar conexiones remotas, que tal si tu boards se encuentra conectado a una máquina diferente.</p>

<p>Y por otra parte los archivos <code>.cfg</code> son una herramienta poderosa al momento de crear diferentes configuraciones para acceder a tu tarjeta.</p>

<p>Así que escoge sabiamente ;) y si quieres mas información consulta el <strong>Manual de usuario de OpenOCD</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/06/instalando-openocd/"/>
    <updated>2014-08-06T11:54:37-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/06/instalando-openocd</id>
    <content type="html"><![CDATA[<p>Ya con el compilador instalado, deberemos instalar un programa que nos permita comunicarnos con nuestro hardware y programarlo. Para ello usaremos <strong>OpenOCD</strong>, el cual es un pequeño servidor que se conectará con nuestro programador/debugger y nos permitirá pasar a nuestro micro el programa ya compilado.</p>

<p><strong>NOTA</strong> Necesitamos instalar unas pequeñas librerias a manera de prerequisito (drivers USB). En Ubuntu escribe
<code>
$ sudo apt-get install libftdi-dev libusb-1.0-0-dev
</code></p>

<p><strong>OpenOCD</strong> es un software totalmente libre y en constante actualización, descarga la versión <strong>0.8.0</strong> de <a href="http://sourceforge.net/projects/openocd/files/openocd/0.8.0/"><strong>Aquí</strong></a>.</p>

<p>Descomprime el archivo descargado con el siguiente comando en la terminal.
<code>
$ tar xvjf openocd-0.8.0.tar.bz2
</code></p>

<!--more-->


<p><strong>OpenOCD</strong> se distribuye usando sus archivos fuente, así que antes de ejecutarlo debemos compilarlo y despues instalarlo. No te preocupes son pasos muy sencillos.</p>

<p>Primero pasate a la carpeta de OpenOCD ya descomprimido
<code>
$ cd openocd-0.8.0
</code></p>

<p>Ahora lo configuraremos para que trabaje con ciertos debuggers, como <strong>jlink</strong>, <strong>ftdi</strong> y <strong>stlink</strong> ( <em>que es el que usaremos nosotros</em> )
<code>
$ ./configure --enable-stlink --enable-jlink --enable-ftdi
</code></p>

<p>Compilamos
<code>
$ make
</code></p>

<p>Por último instalamos
<code>
$ sudo make install
</code></p>

<p><strong>OpenOCD</strong> quedó instalado en dos diferentes folders de nuestro sistema linux, el ejecutable ( <em>binario</em> ) quedará en el directorio <code>/usr/local/bin</code>.</p>

<p>La otra carpeta importante <code>/usr/local/share/openocd/scripts</code> es donde quedarán instalados los scripts que nos servirán para identificar el micro que queremos programar y contiene la información necesaria para decirle a <strong>OpenOCD</strong> como programarlo, estos scripts están agrupados en tres niveles:</p>

<ul>
<li><strong>target.-</strong> scripts con instrucciones especificas para microcontroladores/procesadores</li>
<li><strong>interface.-</strong> scripts con la informacion del debugger/programador a usar</li>
<li><strong>board.-</strong> scripts con instrucciones que combinan interface y target. Y pertenecen a tarjetas especifcas que ya estan en el mercado</li>
</ul>


<p>Antes de prenderle fuego a tu board ( <em>conectarla a OpenOCD</em> ) deberemos registrar ciertas reglas, para que el debugger ( <em>ST-Link-V2-1</em> ) sea reconocido por nuestro sistema. Para no entrar mas en detallas simplemente ejecuta lo siguietne en la terminal.
<code>
$ sudo cp  /usr/local/share/openocd/contrib/openocd.udev  /etc/udev/rules.d/98-openocd.rules
$ sudo udevadm control --reload-rules
</code></p>

<p>Bueno basta de Charla, hay que probar si realmente funciona. Para ello usaremos nuestra nueva tarjeta <strong>Nucleo-F072RB</strong> de la marca <strong>ST</strong>, el cual por cierto posee un micro con CPU <strong>Cortex-M0</strong>. Conectala al puerto USB ( <em>se abrirá una ventana, pues la PC la identificara como un mass storage, no te apures solo cierra la ventana</em> )</p>

<p>En la terminal ejecuta OpenOCD de la siguiente manera.
<code>
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg
</code></p>

<p>Si todo resulto bien te aparecera la siguiente información.
<code>
Open On-Chip Debugger 0.8.0 (2014-08-02-17:39)
Licensed under GNU GPL v2
For bug reports, read
    http://openocd.sourceforge.net/doc/doxygen/bugs.html
Info : This adapter doesn't support configurable speed
Info : STLINK v2 JTAG v22 API v2 SWIM v5 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 3.246689
Info : stm32f0x.cpu: hardware has 4 breakpoints, 2 watchpoints
</code></p>

<p>Con un <code>Ctrl+C</code> sales de openocd.</p>

<p>Si requieres mas informacion consulta:</p>

<ul>
<li><a href="openocd.org">openocd.org</a></li>
<li><a href="http://gnuarmeclipse.livius.net/blog/openocd-install/">http://gnuarmeclipse.livius.net/blog/openocd-install/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando El Compilador GNU ARM]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm/"/>
    <updated>2014-08-05T21:52:45-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm</id>
    <content type="html"><![CDATA[<p>Vamos a empezar con nuestro primer post, y consistira en la instalacion y puesta a punto de nuestra herramienta de desarrollo favorita para microcontroladores <strong>ARM</strong>. El compilador <strong>GCC</strong> es totalemnte libre y lo mejor, no presenta limitacion alguna =).</p>

<p>Primero lo primero, Deberas descargar el toolchain de su pagina oficial <a href="https://launchpad.net/gcc-arm-embedded"><strong>aqui</strong></a>. Si usas linux, como yo =) descarga el archivo <strong>Linux Installation Tarball</strong>.</p>

<p>Habre la terminal y crea un nuevo folder en tu directorio de usuario. Es en este directorio donde quedara instalado nuestro compilador.
<code>
$ mkdir ~/ARM
</code></p>

<p>Descomprime el archivo descargado en el directorio recien creado (sustituye las x por la version que hayas descargado).
<code>
$ tar -xvjf gcc-arm-none-eabi-X_X-xxxxxx-xxxxxxxx-linux.tar.bz2 -C ~/ARM/
</code></p>

<!--more-->


<p>El siguiente paso es agregar el directorio bin a la variable global <strong>PATH</strong> para que sea ejecutable por la terminal en cualquier directorio.
<code>
$ nano ~/.bashrc
</code></p>

<p>Agrega la siguiente linea al final del archivo, sustituye las <strong>x</strong> con el numero de la version que tengas, fijate en el nombre de la carpeta que descomprimiste.
<code>
export PATH=$PATH:$HOME/ARM/gcc-arm-none-eabi-X_X-xxxxxx/bin
</code></p>

<p>Reinicia la terminal y escribe el siguiente comando que te dira la version del toolchain instalado.
<code>
$ arm-none-eabi-gcc -v
</code></p>

<p>Listo ya tienes tu compilador instalado.</p>
]]></content>
  </entry>
  
</feed>
