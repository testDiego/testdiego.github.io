<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arm Tools | Diego Blog]]></title>
  <link href="http://testDiego.github.io/blog/categories/arm-tools/atom.xml" rel="self"/>
  <link href="http://testDiego.github.io/"/>
  <updated>2014-08-15T17:19:43-07:00</updated>
  <id>http://testDiego.github.io/</id>
  <author>
    <name><![CDATA[Diego]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debugging Con OpenOCD Y GDB]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/14/debugging-con-openocd-y-gdb/"/>
    <updated>2014-08-14T23:12:51-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/14/debugging-con-openocd-y-gdb</id>
    <content type="html"><![CDATA[<p>Llegó el momento de sacar mayor provecho al programador de nuestra tarjeta y es que nos solo sirve para programar. <strong>ST-Link</strong> nos sirve para depurar nuestro programa, realizar cosas como ejecuciones paso a paso, colocar breakpoints, revisar el contenido de una variable o registro, etc.</p>

<p>Antes de empezar deberemos tener un proyecto con el cual trabajar, así que tomaremos el proyecto del post <a href="http://testdiego.github.io/blog/2014/08/08/primer-programa-cmsis/"><strong>Primer Programa con CMSIS</strong></a>. Asegúrate de que compile sin errores ( <em>puedes probarlo antes en la tarjeta</em> ).</p>

<p>Bien, hora de conectarse a nuestra <strong>Nucleo-f072</strong> usando <strong>OpenOCD</strong>
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg
</code></p>

<p>Wow!! Espera un segundo, mejor en vez de hacerlo de la manera tradicional, escribamos un archivo <strong>.cfg</strong> con las instrucciones para que <strong>OpenOCD</strong> se conecte. Si ya te conectaste solo presiona <code>Ctrl+C</code> para desconectarte.</p>

<!--more-->


<p>En la misma carpeta de tu proyecto crea el archivo <strong>openocd.cfg</strong>
<code>
$ touch ~/test_f072_CMSIS/openocd.cfg
</code></p>

<p>Abre el archivo recién creado con tu editor de texto favorito y escribe lo siguiente
&#8220;`</p>

<h1>Indicamos que usaremos stlink como programador</h1>

<p>source [find interface/stlink-v2-1.cfg]</p>

<h1>Indicamos que es micro Cortex-M0 de la marca ST</h1>

<p>source [find target/stm32f0x_stlink.cfg]</p>

<h1>usamos hardware reset, para conectarnos solo bajo reset</h1>

<p>reset_config srst_only srst_nogate
&#8220;`</p>

<p>Ahora si, nos conectamos usando <strong>OpenOCD</strong> y el archivo que acabamos de crear.
<code>
$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd
</code></p>

<p>Si tienes dudas de lo anterior, solo recuerda que lo explicamos en el anterior post <a href="http://testdiego.github.io/blog/2014/08/13/programando-con-openocd/"><strong>Programando con OpenOCD</strong></a>.</p>

<h2>Usando GDB</h2>

<p>GDB es uno de los programas que vienen con tu compilador <strong>GNU ARM</strong> el cual instalaste en el <a href="http://testdiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm/"><strong>primer post</strong></a> y basicamente nos servira para ejecutar nuestro programa de manera guiada por asi decirlo. Solo continua con las instrucciones y te daras cuenta a que me refiero.</p>

<p>Abrimos otra terminal y en ella ejecutaremos <strong>gdb</strong> invocando el archivo <strong>.elf</strong> que nos arrojó la compilación de nuestro proyecto ( <em>Revisa la carpeta Output de tu proyecto</em> )
<code>
$ cd ~/test_f072_CMSIS #recuerda que debemos estar en la carpeta del proyecto
$ arm-none-eabi-gdb Output/test.elf
</code></p>

<p><strong>gdb</strong> nos arrojará la siguiente información por pantalla.
<code>
GNU gdb (GNU Tools for ARM Embedded Processors) 7.6.0.20131129-cvs
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "--host=i686-linux-gnu --target=arm-none-eabi".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/diego/test_f072_CMSIS/Output/test.elf...done.
(gdb)
</code></p>

<p>En la terminal tendremos el prompt correspondiente a <strong>gdb</strong> el cual nos indica que se esta ejecutando y que podremos escribir un comando para poner en funcionamiento nuestro programa.</p>

<p>Lo primero que debemos hacer es conectarnos al puerto <strong>3333</strong> que tiene disponible <strong>OpenOCD</strong>
<code>
(gdb) target remote localhost:3333
Remote debugging using localhost:3333
0x00000000 in ?? ()
</code></p>

<p>Ya conectado <strong>OpenOCD</strong> con <strong>GDB</strong> lo siguiente es cargar a la memoria del micro nuestro programa. Lo hacemos con el comando <code>load</code>
<code>
(gdb) load
Loading section .isr_vector, size 0xc0 lma 0x8000000
Loading section .text, size 0x484 lma 0x80000c0
Loading section .rodata, size 0x8 lma 0x8000544
Loading section .init_array, size 0x8 lma 0x800054c
Loading section .fini_array, size 0x4 lma 0x8000554
Loading section .data, size 0x440 lma 0x8000558
Start address 0x8000378, load size 2456
Transfer rate: 12 KB/sec, 409 bytes/write.
</code></p>

<p>Aplicamos un reset para iniciar desde la primera dirección de nuestro programa
<code>
(gdb) mon reset halt
target state: halted
target halted due to debug-request, current mode: Thread
xPSR: 0xc1000000 pc: 0x08000378 msp: 0x20003ffc
</code></p>

<p>A partir de este punto podemos empezar la ejecución del programa que tiene en memoria el micro. Podemos simplemente poner a correr el programa, pero mejor le diremos que solo lo corra hasta cierto punto.</p>

<p>Insertaremos un <strong>breakpoint</strong> justo en la línea del programa que invierte el estado del led. Revisa tu archivo <code>main.c</code> y fijate bien que numero de linea es donde se encuentra la instrucción <code>GPIOA-&gt;ODR ^= (1 &lt;&lt; LED_PIN);</code> . En <strong>gdb</strong> escribe. ( <em>en nuestro caso es la línea 19</em> )
<code>
(gdb) b main.c:19
Breakpoint 1 at 0x8000154: file main.c, line 19.
</code></p>

<p>Ponemos a correr al micro con el comando <code>c</code> de <em>continue</em>
&#8220;`
(gdb) c
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.</p>

<p>Breakpoint 1, main () at main.c:19
19          GPIOA->ODR ^= (1 &lt;&lt; LED_PIN);
&#8220;`</p>

<p>Puedes observar en la terminal como <strong>gdb</strong> te indica que el programa se detuvo justo en la línea donde colocaste el breakpoint.</p>

<p>Vuelve a correr el programa con el comando <code>c</code> y observaras de nueva cuenta que se detiene en el <strong>breakpoint</strong>, observa tu tarjeta y ve como cada que presionas el comando <code>c</code> el led se invierte.</p>

<p>Puedes colocar mas <strong>breakpoints</strong> en diferentes lugares de tu código, solo no te olvides donde los pusiste, y si se te olvide solo escribe <code>info break</code>
<code>
(gdb) info break
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x08000154 in main at main.c:19
    breakpoint already hit 2 times
</code></p>

<p>Si quieres que el program no se detenga y se ejecute de manera continua tendrás que borrar el <strong>breakpoint</strong>. Lo puedes hacer con <code>clear</code>
<code>
(gdb) clear main.c:19
Deleted breakpoints 1
</code></p>

<p>En este caso el breakpoint estaba en el archivo <code>main.c</code>, linea <strong>19</strong></p>

<p>Escribe <code>c</code> para que tu program empiece a correr, ya sin ningun breakpoint que lo detenga. Mira como parpadea el led!!.</p>

<p>Para detener la ejecución de tu programa tendrás que ejecutar un <code>Ctrl+C</code>. El programa se detendrá justo en la instrucción que estaba ejecutando. En nuestro caso fue el ciclo for
<code>
^C
Program received signal SIGINT, Interrupt.
0x0800016e in main () at main.c:21
21          for(i=0;i&lt;300000;i++);
</code></p>

<p>Para salir de <strong>gdb</strong> solo escribe <code>q</code>, nos pedira confirmacion asi que tecleamos <code>y</code>
&#8220;`
(gdb) q
A debugging session is active.</p>

<pre><code>Inferior 1 [Remote target] will be detached.
</code></pre>

<p>Quit anyway? (y or n) y
Detaching from program: /home/diego/test_f072_CMSIS/Output/test.elf, Remote target
Ending remote debugging.
&#8220;`</p>

<p>Que tal, a que no sabias que se podía hacer. Nah, probablemente si. Para terminar <strong>GDB</strong> es una herramienta muy buena para depurar y encontrar errores en tu programa cuando estas en la fase de desarrollo. Hay muchas cosas mas interesantes que se pueden hacer con gdb, pero eso lo veremos mas adelante.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programando Con OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/13/programando-con-openocd/"/>
    <updated>2014-08-13T20:39:06-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/13/programando-con-openocd</id>
    <content type="html"><![CDATA[<p>Existen diferentes maneras en que podemos programar nuestro microcontrolador usando <strong>OpenOCD</strong>, ( <em>una muestra de su versatilidad</em> ), y en este nuevo post examinaremos algunas de ellas, quedara en ti escoger la más adecuada para tu sistema de trabajo.</p>

<p>Antes que nada y para simplificar un poco utilizaremos el programa que creamos en el post <a href="http://testdiego.github.io/blog/2014/08/06/primer-programa-bare-board"><strong>Primer Programa Bare Board</strong></a> y daremos por echo que ya esta correctamente compilado y tenemos los archivos tets.elf y test.hex generados en el subfolder Output.</p>

<h2>Usando Telnet</h2>

<p>Esta opción ya la hemos manejado en los anteriores post, pero no está de más incluirla aquí. Primero que nada tendrás que conectarte a tu tarjeta con <strong>OpenOCD</strong>
<code>
$ cd ~/test_f072 #recuerda que debemos estar en alcarpeta del proyecto
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg
</code></p>

<!--more-->


<p>Recuerda que debes indicar la interfaz que manejas ( <em>en este caso stlink</em> ) y el micro a programar ( <em>en este caso stm32f0</em> ). Y eso es lo que se hace en el código de arriba.</p>

<p>Por default <strong>OpenOCD</strong> estará escuchando en el <strong>puerto 4444</strong> para aceptar conexiones por <strong>telnet</strong>, así que lo siguiente es usar el programa <strong>telnet</strong> para conectarnos a ese mismo puerto. En otra terminal escribimos
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ telnet localhost 4444
</code></p>

<p>Notamos como <strong>OpenOCD</strong> nos acepta la conexión, con lo cual estamos listos para mandarle comandos y que este los ejecute. Puedes investigar cuales son los comandos que acepta <strong>OpenOCD</strong> leyendo su manual de usuario.</p>

<p>Para programar la memoria del micro se usarán los siguientes
<code>
reset halt
flash write_image erase Output/test.hex
reset run
exit
</code></p>

<p>El primer comando resetea y detiene al micro, el segundo manda el programa y lo escribe en la memoria y el último lo resetea y pone a correr el programa, asi que ya podras ver un feliz led parpadeando.</p>

<h2>Usando solo OpenOCD</h2>

<p>Se puede usar únicamente <strong>OpenOCD</strong> sin necesitar de un programa externo como <strong>telnet</strong> para programar el micro. Simplemente le debes pasar algunos comandos a <strong>OpenOCD</strong> al momento de invocarlo
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg -c "program Output/test.hex verify reset"
</code></p>

<p>Si observas bien puedes darte cuenta que con la bandera <code>-c</code> puedes pasar comandos a <strong>OpenOCD</strong>. En este caso le estamos indicando que programe el micro con el archivo <strong>.hex</strong> <code>Output/test.hex</code> y que después de hacer la programación realice una verificación y un reset.</p>

<p>Esta nueva forma hace que <strong>OpenOCD</strong> se conecte a nuestro micro, cargue el programa, lo verifique y ponga correr el programa para después desconectarse de la tarjeta.</p>

<h2>Usando Archivos .cfg con OpenOCD</h2>

<p>El anterior método resultó ser mucho más corto y sencillo que el anterior con <strong>telnet</strong>, pero en contra está la kilométrica línea con la que debemos invocar <strong>OpenOCD</strong> desde la terminal. Lo cual lo hace bastante engorroso y fácil de cometer equivocaciones.</p>

<p>Para evitar lo anterior escribiremos los argumentos con los que invocamos <strong>OpenOCD</strong> en un archivo <code>.cfg</code> ( <em>que son los que entiende OpenOCD</em> ) así que en la misma carpeta de tu proyecto crea el archivo <strong>openocd.cfg</strong>
<code>
$ touch ~/test_f072/openocd.cfg
</code></p>

<p>Abre el archivo recién creado con tu editor de texto favorito y escribe lo siguiente
&#8220;`</p>

<h1>Indicamos que usaremos stlink como programador</h1>

<p>source [find interface/stlink-v2-1.cfg]</p>

<h1>Indicamos que es micro Cortex-M0 de la marca ST</h1>

<p>source [find target/stm32f0x_stlink.cfg]</p>

<h1>Programamos el archivo &ldquo;test.hex&rdquo; que se encuentra en la carpeta</h1>

<h1>Output de nuestro proyecto y despues verificamos y damos un reset</h1>

<p>program Output/test.hex verify reset</p>

<pre><code>
Ahora tenemos los anteriores parámetros escritos en un archivo en la carpeta de nuestro proyecto, con lo cual invocar **OpenOCD** se vuelve mas sencillo. Solo escribimos
</code></pre>

<p>$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd -f openocd.cfg
&#8220;`</p>

<p>Como puedes ver a <strong>OpenOCD</strong> lo invocamos pasando el nombre del archivo que contiene los comandos que se deben ejecutar al conectarse a nuestra tarjeta. Un metodo simple y rápido, que nos da pie a crear formas más flexibles de conectarnos y programar nuestros dispositivos.</p>

<p>Antes de terminar!!. ¿Porque nombramos a nuestro arcgivo <code>.cfg</code> con el nombre de <code>openocd</code>?, ¿por puro gusto?, ¿simple coincidencia?. No, fue intencional y es que resulta que <strong>OpenOCD</strong> por default se ejecutara con el archivo llamado <code>openocd.cfg</code> que se encuentre en el directorio en el que fue invocado.</p>

<p>Asi que podemos simplifar lo anterior aun mas
<code>
$ cd ~/test_f072 #recuerda que debemos estar en la carpeta del proyecto
$ sudo openocd
</code></p>

<h2>Conclusion</h2>

<p>Como puedes ver unas opciones parecen ser mejores que otras. Bueno eso dependerá de la forma que uses <strong>OpenOCD</strong>. Con telnet tienes una opción poderosa para realizar conexiones remotas, que tal si tu boards se encuentra conectado a una máquina diferente.</p>

<p>Y por otra parte los archivos <code>.cfg</code> son una herramienta poderosa al momento de crear diferentes configuraciones para acceder a tu tarjeta. Como sugrerencia crea el archivo <code>openocd.cfg</code> en la carpeta de cada proyecto en el que trabajes y veras como te ahorras tiempo al programar.</p>

<p>Si quieres mas información consulta el <strong>Manual de usuario de OpenOCD</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando OpenOCD]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/06/instalando-openocd/"/>
    <updated>2014-08-06T11:54:37-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/06/instalando-openocd</id>
    <content type="html"><![CDATA[<p>Ya con el compilador instalado, deberemos instalar un programa que nos permita comunicarnos con nuestro hardware y programarlo. Para ello usaremos <strong>OpenOCD</strong>, el cual es un pequeño servidor que se conectará con nuestro programador/debugger y nos permitirá pasar a nuestro micro el programa ya compilado.</p>

<p><strong>NOTA</strong> Necesitamos instalar unas pequeñas librerias a manera de prerequisito (drivers USB). En Ubuntu escribe
<code>
$ sudo apt-get install libftdi-dev libusb-1.0-0-dev
</code></p>

<p><strong>OpenOCD</strong> es un software totalmente libre y en constante actualización, descarga la versión <strong>0.8.0</strong> de <a href="http://sourceforge.net/projects/openocd/files/openocd/0.8.0/"><strong>Aquí</strong></a>.</p>

<p>Descomprime el archivo descargado con el siguiente comando en la terminal.
<code>
$ tar xvjf openocd-0.8.0.tar.bz2
</code></p>

<!--more-->


<p><strong>OpenOCD</strong> se distribuye usando sus archivos fuente, así que antes de ejecutarlo debemos compilarlo y despues instalarlo. No te preocupes son pasos muy sencillos.</p>

<p>Primero pasate a la carpeta de OpenOCD ya descomprimido
<code>
$ cd openocd-0.8.0
</code></p>

<p>Ahora lo configuraremos para que trabaje con ciertos debuggers, como <strong>jlink</strong>, <strong>ftdi</strong> y <strong>stlink</strong> ( <em>que es el que usaremos nosotros</em> )
<code>
$ ./configure --enable-stlink --enable-jlink --enable-ftdi
</code></p>

<p>Compilamos
<code>
$ make
</code></p>

<p>Por último instalamos
<code>
$ sudo make install
</code></p>

<p><strong>OpenOCD</strong> quedó instalado en dos diferentes folders de nuestro sistema linux, el ejecutable ( <em>binario</em> ) quedará en el directorio <code>/usr/local/bin</code>.</p>

<p>La otra carpeta importante <code>/usr/local/share/openocd/scripts</code> es donde quedarán instalados los scripts que nos servirán para identificar el micro que queremos programar y contiene la información necesaria para decirle a <strong>OpenOCD</strong> como programarlo, estos scripts están agrupados en tres niveles:</p>

<ul>
<li><strong>target.-</strong> scripts con instrucciones especificas para microcontroladores/procesadores</li>
<li><strong>interface.-</strong> scripts con la informacion del debugger/programador a usar</li>
<li><strong>board.-</strong> scripts con instrucciones que combinan interface y target. Y pertenecen a tarjetas especifcas que ya estan en el mercado</li>
</ul>


<p>Antes de prenderle fuego a tu board ( <em>conectarla a OpenOCD</em> ) deberemos registrar ciertas reglas, para que el debugger ( <em>ST-Link-V2-1</em> ) sea reconocido por nuestro sistema. Para no entrar mas en detallas simplemente ejecuta lo siguietne en la terminal.
<code>
$ sudo cp  /usr/local/share/openocd/contrib/openocd.udev  /etc/udev/rules.d/98-openocd.rules
$ sudo udevadm control --reload-rules
</code></p>

<p>Bueno basta de Charla, hay que probar si realmente funciona. Para ello usaremos nuestra nueva tarjeta <strong>Nucleo-F072RB</strong> de la marca <strong>ST</strong>, el cual por cierto posee un micro con CPU <strong>Cortex-M0</strong>. Conectala al puerto USB ( <em>se abrirá una ventana, pues la PC la identificara como un mass storage, no te apures solo cierra la ventana</em> )</p>

<p>En la terminal ejecuta OpenOCD de la siguiente manera.
<code>
$ sudo openocd -f interface/stlink-v2-1.cfg -f target/stm32f0x_stlink.cfg
</code></p>

<p>Si todo resulto bien te aparecera la siguiente información.
<code>
Open On-Chip Debugger 0.8.0 (2014-08-02-17:39)
Licensed under GNU GPL v2
For bug reports, read
    http://openocd.sourceforge.net/doc/doxygen/bugs.html
Info : This adapter doesn't support configurable speed
Info : STLINK v2 JTAG v22 API v2 SWIM v5 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 3.246689
Info : stm32f0x.cpu: hardware has 4 breakpoints, 2 watchpoints
</code></p>

<p>Con un <code>Ctrl+C</code> sales de openocd.</p>

<p>Si requieres mas informacion consulta:</p>

<ul>
<li><a href="openocd.org">openocd.org</a></li>
<li><a href="http://gnuarmeclipse.livius.net/blog/openocd-install/">http://gnuarmeclipse.livius.net/blog/openocd-install/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instalando El Compilador GNU ARM]]></title>
    <link href="http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm/"/>
    <updated>2014-08-05T21:52:45-07:00</updated>
    <id>http://testDiego.github.io/blog/2014/08/05/instalando-el-compilador-gnu-arm</id>
    <content type="html"><![CDATA[<p>Vamos a empezar con nuestro primer post, y consistira en la instalacion y puesta a punto de nuestra herramienta de desarrollo favorita para microcontroladores <strong>ARM</strong>. El compilador <strong>GCC</strong> es totalemnte libre y lo mejor, no presenta limitacion alguna =).</p>

<p>Primero lo primero, Deberas descargar el toolchain de su pagina oficial <a href="https://launchpad.net/gcc-arm-embedded"><strong>aqui</strong></a>. Si usas linux, como yo =) descarga el archivo <strong>Linux Installation Tarball</strong>.</p>

<p>Habre la terminal y crea un nuevo folder en tu directorio de usuario. Es en este directorio donde quedara instalado nuestro compilador.
<code>
$ mkdir ~/ARM
</code></p>

<p>Descomprime el archivo descargado en el directorio recien creado (sustituye las x por la version que hayas descargado).
<code>
$ tar -xvjf gcc-arm-none-eabi-X_X-xxxxxx-xxxxxxxx-linux.tar.bz2 -C ~/ARM/
</code></p>

<!--more-->


<p>El siguiente paso es agregar el directorio bin a la variable global <strong>PATH</strong> para que sea ejecutable por la terminal en cualquier directorio.
<code>
$ nano ~/.bashrc
</code></p>

<p>Agrega la siguiente linea al final del archivo, sustituye las <strong>x</strong> con el numero de la version que tengas, fijate en el nombre de la carpeta que descomprimiste.
<code>
export PATH=$PATH:$HOME/ARM/gcc-arm-none-eabi-X_X-xxxxxx/bin
</code></p>

<p>Reinicia la terminal y escribe el siguiente comando que te dira la version del toolchain instalado.
<code>
$ arm-none-eabi-gcc -v
</code></p>

<p>Listo ya tienes tu compilador instalado.</p>
]]></content>
  </entry>
  
</feed>
